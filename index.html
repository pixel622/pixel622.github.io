<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pokémon K&E Version</title>
    <style>
        :root {
            --gba-blue: #285088;
            --gba-light-blue: #5888c8;
            --font-main: 'Courier New', Courier, monospace;
            --type-grass: #78C850;
            --type-water: #6890F0;
            --type-fire: #F08030;
            --type-rock: #B8A038;
            --type-normal: #A8A878;
            --type-bug: #A8B820;
            --type-poison: #A040A0;
            --type-fighting: #C03028;
        }

        body, html {
            margin: 0; padding: 0; 
            width: 100vw; height: 100vh;
            background: #000; overflow: hidden; 
            touch-action: none;
            display: flex; justify-content: center; align-items: center;
            font-family: var(--font-main);
        }

        #game-wrapper {
            position: relative;
            width: 100%; height: 100%;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            image-rendering: pixelated;
        }

        #title-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a237e 0%, #283593 100%); color: #fff;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 2000; transition: opacity 0.5s ease-out;
        }

        #title-screen h1 { 
            font-size: 48px; 
            margin-bottom: 20px; 
            text-align: center; 
            color: #ffcb05; 
            text-shadow: 3px 3px #2a75bb, 6px 6px rgba(0,0,0,0.3);
            letter-spacing: 2px;
        }

        .title-subtitle {
            color: #ffcb05;
            margin-bottom: 40px;
            font-size: 20px;
            text-shadow: 1px 1px #2a75bb;
        }

        #start-btn {
            padding: 15px 40px; font-size: 20px; font-family: var(--font-main);
            background: linear-gradient(to bottom, #2a75bb, #1a237e); 
            color: #ffcb05; 
            border: 4px solid #ffcb05;
            cursor: pointer; border-radius: 10px; font-weight: bold;
            text-shadow: 1px 1px #000;
            box-shadow: 0 4px 0 #1a237e;
            transition: all 0.1s;
        }

        #start-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0px 0 #1a237e;
        }

        #ui-layer {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%); width: 90%;
            z-index: 100; cursor: pointer; display: none;
        }

        #dialogue-box {
            background: white; border: 6px solid var(--gba-blue); border-radius: 18px;
            padding: 20px; font-family: var(--font-main); font-weight: bold;
            font-size: 20px; box-shadow: inset 0 0 0 3px var(--gba-light-blue), 0 4px 10px rgba(0,0,0,0.5);
            min-height: 80px; user-select: none;
            line-height: 1.4;
        }

        #speaker-tag {
            position: absolute; top: -25px; left: 30px;
            background: var(--gba-blue); color: #ffcb05;
            padding: 5px 20px; border-radius: 10px 10px 0 0;
            font-size: 16px; border: 3px solid #ffcb05;
            font-weight: bold;
        }

        #joystick-wrapper {
            position: absolute; bottom: 80px; left: 40px;
            width: 130px; height: 130px;
            background: rgba(255,255,255,0.15); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
            display: flex; justify-content: center; align-items: center; z-index: 200;
        }

        #joystick-knob { 
            width: 50px; height: 50px; 
            background: radial-gradient(circle, rgba(255,255,255,0.8) 30%, rgba(255,255,255,0.3) 100%);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #shimmer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none;
            transition: opacity 0.3s; z-index: 999;
        }

        #bag-btn {
            position: absolute; bottom: 80px; right: 40px;
            background: linear-gradient(to bottom, #2a75bb, #1a237e);
            color: #ffcb05;
            padding: 15px 30px; border-radius: 8px;
            font-family: var(--font-main); font-weight: bold;
            border: 3px solid #ffcb05; cursor: pointer; z-index: 300;
            box-shadow: 0 4px 0 #183058;
            text-shadow: 1px 1px #000;
        }
        #bag-btn:active { 
            transform: translateY(2px); 
            box-shadow: 0 2px 0 #183058; 
        }

        /* BATTLE UI STYLES */
        #battle-ui {
            display: none; position: absolute; top: 0; left: 0;
            width: 100%; height: 100%; 
            background: linear-gradient(135deg, #0a1929 0%, #1a3a5f 100%); 
            z-index: 4000;
            font-family: var(--font-main); color: white;
        }
        #battle-screen {
            width: 100%; height: 100%;
            background: linear-gradient(to bottom, #2a75bb, #1a3a5f);
            position: relative;
            overflow: hidden;
        }
        
        /* Battle Arena */
        #battle-arena {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 70%;
            background: linear-gradient(180deg, #88c070 0%, #a8d890 30%, #70a850 100%);
        }
        
        /* Player Pokémon Side */
        #player-side {
            position: absolute;
            bottom: 150px;
            left: 100px;
            width: 200px;
            height: 200px;
            z-index: 10;
        }
        
        /* Wild Pokémon Side */
        #wild-side {
            position: absolute;
            top: 100px;
            right: 100px;
            width: 200px;
            height: 200px;
            z-index: 10;
        }
        
        /* Battle Info Panel */
        #battle-info {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: rgba(0, 0, 0, 0.9);
            border-top: 4px solid #ffcb05;
            padding: 20px;
            box-sizing: border-box;
        }
        
        /* Battle Controls */
        #battle-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .battle-hp-bar { 
            height: 16px; 
            background: #3a1a1a; 
            border: 2px solid #000; 
            border-radius: 8px;
            overflow: hidden;
            margin: 5px 0;
        }
        .battle-hp-fill { 
            height: 100%; 
            background: linear-gradient(to right, #00cc00, #88ff88);
            transition: width 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: inset 0 0 10px rgba(0,255,0,0.3);
        }
        
        .hp-text {
            font-size: 14px;
            color: #ffcb05;
            font-weight: bold;
        }
        
        .battle-btn { 
            padding: 15px; 
            background: linear-gradient(to bottom, #285088, #1a237e); 
            color: #ffcb05; border: 3px solid #ffcb05;
            border-radius: 10px; cursor: pointer; font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px #000;
            box-shadow: 0 4px 0 #1a237e;
            transition: all 0.1s;
        }
        .battle-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1a237e;
        }
        .battle-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #battle-text {
            background: rgba(40, 80, 136, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #5888c8;
            min-height: 60px;
            font-size: 18px;
            line-height: 1.4;
        }
        
        .battle-type-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
            text-shadow: none;
        }
        
        .battle-stats {
            font-size: 14px;
            margin-top: 5px;
            color: #cccccc;
        }
        
        /* Battle Animation Effects */
        .battle-animation {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Encounter Alert */
        #encounter-alert {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 6px solid #ffcb05;
            border-radius: 20px;
            padding: 30px;
            z-index: 5000;
            width: 80%;
            max-width: 500px;
            text-align: center;
        }
        
        #encounter-alert h2 {
            color: #ffcb05;
            margin-top: 0;
            font-size: 28px;
        }
        
        #encounter-alert p {
            font-size: 20px;
            margin: 20px 0;
        }
        
        .encounter-btn {
            padding: 15px 30px;
            margin: 10px;
            background: linear-gradient(to bottom, #285088, #1a237e);
            color: #ffcb05;
            border: 3px solid #ffcb05;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            min-width: 150px;
        }
        
        /* BAG MODAL STYLES */
        #bag-menu {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 80%; max-width: 400px;
            background: linear-gradient(135deg, #f8f8f8 0%, #e8e8e8 100%);
            border: 6px solid var(--gba-blue); border-radius: 15px;
            z-index: 3000; font-family: var(--font-main); padding: 20px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        #bag-menu h2 { 
            margin: 0 0 15px 0; color: var(--gba-blue); 
            border-bottom: 2px solid #ccc;
            padding-bottom: 10px;
            text-align: center;
        }
        .bag-item { 
            padding: 10px; 
            border-bottom: 1px solid #ddd; 
            display: flex; 
            justify-content: space-between;
            align-items: center;
        }
        .bag-item:hover {
            background: rgba(40, 80, 136, 0.1);
        }
        #close-bag { 
            margin-top: 15px; width: 100%; padding: 10px; 
            background: linear-gradient(to bottom, #cc0000, #880000); 
            color: white; border: none; border-radius: 5px; 
            cursor: pointer; font-weight: bold;
            border: 2px solid #ff4444;
        }

        /* Move selection modal */
        #move-selector {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #ffcb05;
            border-radius: 10px;
            padding: 15px;
            z-index: 5000;
        }
        
        .move-option {
            padding: 12px;
            margin: 5px 0;
            background: rgba(40, 80, 136, 0.8);
            border: 2px solid #5888c8;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
        }
        .move-option:hover {
            background: rgba(88, 136, 200, 0.9);
            transform: translateX(5px);
        }
        .move-type {
            float: right;
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 3px;
        }
        .move-details {
            font-size: 12px;
            color: #cccccc;
            margin-top: 5px;
        }

        /* Type colors */
        .type-grass { background: var(--type-grass); color: #000; }
        .type-water { background: var(--type-water); color: #fff; }
        .type-fire { background: var(--type-fire); color: #fff; }
        .type-rock { background: var(--type-rock); color: #fff; }
        .type-normal { background: var(--type-normal); color: #000; }
        .type-bug { background: var(--type-bug); color: #fff; }
        .type-poison { background: var(--type-poison); color: #fff; }
        .type-fighting { background: var(--type-fighting); color: #fff; }

        /* Battle status indicators */
        .battle-status {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 20;
        }
        
        /* Terrain indicators on overworld */
        .terrain-indicator {
            position: absolute;
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="title-screen">
        <h1>Pokémon K&E Version</h1>
        <div class="title-subtitle">Habitat Research Edition</div>
        <button id="start-btn" onclick="startGame()">START GAME</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="shimmer"></div>
    <div id="bag-btn" onclick="toggleBag(true)">BAG</div>

    <!-- Encounter Alert -->
    <div id="encounter-alert">
        <h2>Wild Pokémon!</h2>
        <p>A wild <span id="encounter-pokemon-name">Pokémon</span> wants to battle!</p>
        <div>
            <button class="encounter-btn" onclick="startBattleFromEncounter()">FIGHT</button>
            <button class="encounter-btn" onclick="avoidEncounter()">AVOID</button>
        </div>
    </div>

    <!-- Battle UI -->
    <div id="battle-ui">
        <div id="battle-screen">
            <div id="battle-arena"></div>
            
            <!-- Player Pokémon -->
            <div id="player-side">
                <canvas id="player-battle-sprite" width="200" height="200"></canvas>
                <div class="battle-status" id="player-status">Lv. 5</div>
                <div style="position: absolute; bottom: -50px; left: 0; width: 200px;">
                    <div class="hp-text" id="player-hp-text">HP: 100/100</div>
                    <div class="battle-hp-bar">
                        <div id="player-hp-fill" class="battle-hp-fill" style="width: 100%"></div>
                    </div>
                    <div id="player-type" class="battle-stats"></div>
                </div>
            </div>
            
            <!-- Wild Pokémon -->
            <div id="wild-side">
                <canvas id="wild-battle-sprite" width="200" height="200"></canvas>
                <div class="battle-status" id="wild-status">Lv. 5</div>
                <div style="position: absolute; bottom: -50px; left: 0; width: 200px;">
                    <div class="hp-text" id="wild-hp-text">HP: 100/100</div>
                    <div class="battle-hp-bar">
                        <div id="wild-hp-fill" class="battle-hp-fill" style="width: 100%"></div>
                    </div>
                    <div id="wild-type" class="battle-stats"></div>
                </div>
            </div>
            
            <!-- Battle Info -->
            <div id="battle-info">
                <div id="battle-text">What will you do?</div>
                
                <!-- Move Selector -->
                <div id="move-selector">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <!-- Move options populated by JavaScript -->
                    </div>
                    <button class="battle-btn" onclick="cancelMove()" style="margin-top: 10px; width: 100%;">BACK</button>
                </div>
                
                <!-- Battle Controls -->
                <div id="battle-controls">
                    <button class="battle-btn" onclick="showMoveSelector()" id="fight-btn">FIGHT</button>
                    <button class="battle-btn" onclick="battleAction('bag')" id="bag-btn-battle">BAG</button>
                    <button class="battle-btn" onclick="battleAction('pokemon')" id="pokemon-btn">POKÉMON</button>
                    <button class="battle-btn" onclick="battleAction('run')" id="run-btn">RUN</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bag Modal -->
    <div id="bag-menu">
        <h2>ADVENTURE BAG</h2>
        <div id="bag-content"></div>
        <button id="close-bag" onclick="toggleBag(false)">CLOSE</button>
    </div>

    <div id="ui-layer" onclick="handleDialogueClick()">
        <div id="speaker-tag">Professor Sequoia</div>
        <div id="dialogue-box">Welcome to the Habitat Research Lab! We're studying how Pokémon adapt to different terrains in Orebound. Please choose a partner to help with our research.</div>
    </div>

    <div id="joystick-wrapper">
        <div id="joystick-knob"></div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const knob = document.getElementById('joystick-knob');
    const wrapper = document.getElementById('joystick-wrapper');
    const uiLayer = document.getElementById('ui-layer');
    const dialogueBox = document.getElementById('dialogue-box');
    const titleScreen = document.getElementById('title-screen');
    const bagMenu = document.getElementById('bag-menu');
    const battleUI = document.getElementById('battle-ui');
    const encounterAlert = document.getElementById('encounter-alert');

    // Type effectiveness chart (simplified)
    const typeEffectiveness = {
        'GRASS': { strong: ['WATER', 'ROCK', 'GROUND'], weak: ['FIRE', 'BUG', 'FLYING', 'POISON'] },
        'FIRE': { strong: ['GRASS', 'BUG', 'ICE'], weak: ['WATER', 'ROCK', 'GROUND'] },
        'WATER': { strong: ['FIRE', 'ROCK', 'GROUND'], weak: ['GRASS', 'ELECTRIC'] },
        'ROCK': { strong: ['FIRE', 'BUG', 'FLYING'], weak: ['WATER', 'GRASS', 'FIGHTING', 'GROUND'] },
        'BUG': { strong: ['GRASS', 'PSYCHIC'], weak: ['FIRE', 'FLYING', 'ROCK'] },
        'NORMAL': { strong: [], weak: ['FIGHTING'] },
        'POISON': { strong: ['GRASS'], weak: ['PSYCHIC', 'GROUND'] },
        'FIGHTING': { strong: ['NORMAL', 'ROCK', 'ICE'], weak: ['FLYING', 'PSYCHIC'] },
        'GROUND': { strong: ['FIRE', 'ROCK', 'POISON'], weak: ['WATER', 'GRASS', 'ICE'] }
    };

    // Moves database
    const moveDatabase = {
        'Tackle': { type: 'NORMAL', power: 40, accuracy: 100, pp: 35, effect: null },
        'Vine Whip': { type: 'GRASS', power: 45, accuracy: 100, pp: 25, effect: null },
        'Ember': { type: 'FIRE', power: 40, accuracy: 100, pp: 25, effect: null },
        'Water Gun': { type: 'WATER', power: 40, accuracy: 100, pp: 25, effect: null },
        'Rock Throw': { type: 'ROCK', power: 50, accuracy: 90, pp: 15, effect: null },
        'Bug Bite': { type: 'BUG', power: 60, accuracy: 100, pp: 20, effect: null },
        'Poison Sting': { type: 'POISON', power: 15, accuracy: 100, pp: 35, effect: 'POISON' },
        'Karate Chop': { type: 'FIGHTING', power: 50, accuracy: 100, pp: 25, effect: null },
        'Mud Slap': { type: 'GROUND', power: 20, accuracy: 100, pp: 10, effect: 'ACCURACY_DOWN' }
    };

    // Game state variables
    const script = [
        "Welcome to the Habitat Research Lab!",
        "Look around! This facility is dedicated to studying Orebound's ecology.",
        "The tremor earlier was quite strong. We must act quickly.",
        "Go ahead and click on the Pokémon you want to partner with!"
    ];
    let scriptIndex = 0;
    let currentMap = 'LAB';
    let choosingState = false;
    let holdingPokeball = false; 
    let isBagOpen = false;
    let inBattle = false;
    let width, height;
    let pendingEncounter = null;

    // Player inventory
    const playerInventory = {
        pokeballs: 5,
        potions: 3,
        capturedPokemon: []
    };

    // Enhanced Pokémon data with types, moves, and stats
    const pokemonDatabase = {
        'bulbasaur': {
            terrain: 'GRASS',
            type: 'GRASS',
            secondaryType: 'POISON',
            color: '#74C874',
            moves: ['Tackle', 'Vine Whip', 'Poison Sting'],
            sprite: [
                '  ████████  ',
                ' ████░░████ ',
                ' ██░░░░░░██ ',
                ' ██░░██░░██ ',
                '  ████████  ',
                '    ████    ',
                '   ████    '
            ],
            hp: 45,
            attack: 49,
            defense: 49,
            speed: 45,
            level: 5
        },
        'caterpie': {
            terrain: 'GRASS',
            type: 'BUG',
            secondaryType: null,
            color: '#98D898',
            moves: ['Tackle', 'Bug Bite'],
            sprite: [
                '    ████    ',
                '  ██░░░░██  ',
                ' ██░░░░░░██ ',
                '  ████████  ',
                '   ██████   '
            ],
            hp: 45,
            attack: 30,
            defense: 35,
            speed: 45,
            level: 3
        },
        'weedle': {
            terrain: 'GRASS',
            type: 'BUG',
            secondaryType: 'POISON',
            color: '#D8B850',
            moves: ['Tackle', 'Poison Sting'],
            sprite: [
                '    ██      ',
                '  ██░░██    ',
                ' ██░░░░██   ',
                '  ██████    ',
                '   ████     '
            ],
            hp: 40,
            attack: 35,
            defense: 30,
            speed: 50,
            level: 3
        },
        'oddish': {
            terrain: 'GRASS',
            type: 'GRASS',
            secondaryType: 'POISON',
            color: '#A890F0',
            moves: ['Tackle', 'Vine Whip'],
            sprite: [
                '   ██████   ',
                '  ██░░░░██  ',
                ' ██░░░░░░██ ',
                '  ██░░░░██  ',
                '   ██████   ',
                '    ████    '
            ],
            hp: 45,
            attack: 50,
            defense: 55,
            speed: 30,
            level: 5
        },
        'bellsprout': {
            terrain: 'GRASS',
            type: 'GRASS',
            secondaryType: 'POISON',
            color: '#78C850',
            moves: ['Tackle', 'Vine Whip'],
            sprite: [
                '    ████    ',
                '   ██░░██   ',
                '  ██░░░░██  ',
                ' ██░░░░░░██ ',
                '  ████████  '
            ],
            hp: 50,
            attack: 75,
            defense: 35,
            speed: 40,
            level: 5
        },
        'geodude': {
            terrain: 'ROCKY',
            type: 'ROCK',
            secondaryType: 'GROUND',
            color: '#B8A038',
            moves: ['Tackle', 'Rock Throw', 'Mud Slap'],
            sprite: [
                '  ████████  ',
                ' ██░░░░░░██ ',
                '██░░░░░░░░██',
                '██░░░░░░░░██',
                ' ██████████ '
            ],
            hp: 40,
            attack: 80,
            defense: 100,
            speed: 20,
            level: 7
        },
        'onix': {
            terrain: 'ROCKY',
            type: 'ROCK',
            secondaryType: 'GROUND',
            color: '#A8A878',
            moves: ['Tackle', 'Rock Throw'],
            sprite: [
                '██          ',
                '██████      ',
                '  ████████  ',
                '    ████████',
                '      ██████'
            ],
            hp: 35,
            attack: 45,
            defense: 160,
            speed: 70,
            level: 8
        },
        'rhyhorn': {
            terrain: 'ROCKY',
            type: 'ROCK',
            secondaryType: 'GROUND',
            color: '#C0C0C0',
            moves: ['Tackle', 'Rock Throw'],
            sprite: [
                '    ████    ',
                '  ████████  ',
                ' ██░░░░░░██ ',
                '████████████',
                '  ████████  '
            ],
            hp: 80,
            attack: 85,
            defense: 95,
            speed: 25,
            level: 10
        },
        'nosepass': {
            terrain: 'ROCKY',
            type: 'ROCK',
            secondaryType: null,
            color: '#786848',
            moves: ['Tackle', 'Rock Throw'],
            sprite: [
                '  ██████    ',
                ' ██░░░░██   ',
                '██░░░░░░██  ',
                ' ████████   ',
                '  ██████    '
            ],
            hp: 30,
            attack: 45,
            defense: 135,
            speed: 30,
            level: 6
        },
        'aron': {
            terrain: 'ROCKY',
            type: 'ROCK',
            secondaryType: 'STEEL',
            color: '#8898A8',
            moves: ['Tackle', 'Rock Throw'],
            sprite: [
                '    ████    ',
                '  ████████  ',
                ' ██░░░░░░██ ',
                '  ████████  ',
                '   ██████   '
            ],
            hp: 50,
            attack: 70,
            defense: 100,
            speed: 30,
            level: 9
        },
        'magikarp': {
            terrain: 'WATER',
            type: 'WATER',
            secondaryType: null,
            color: '#F08030',
            moves: ['Tackle'],
            sprite: [
                '  ██████    ',
                ' ██░░░░██   ',
                '██░░░░░░██  ',
                ' ██░░░░██   ',
                '  ██████    '
            ],
            hp: 20,
            attack: 10,
            defense: 55,
            speed: 80,
            level: 2
        },
        'psyduck': {
            terrain: 'WATER',
            type: 'WATER',
            secondaryType: null,
            color: '#F8D030',
            moves: ['Tackle', 'Water Gun'],
            sprite: [
                '   ██████   ',
                '  ██░░░░██  ',
                ' ██░░░░░░██ ',
                '  ████████  ',
                '    ████    '
            ],
            hp: 50,
            attack: 52,
            defense: 48,
            speed: 55,
            level: 6
        },
        'poliwag': {
            terrain: 'WATER',
            type: 'WATER',
            secondaryType: null,
            color: '#6890F0',
            moves: ['Tackle', 'Water Gun'],
            sprite: [
                '  ████████  ',
                ' ██░░░░░░██ ',
                '  ████████  ',
                '   ██████   '
            ],
            hp: 40,
            attack: 50,
            defense: 40,
            speed: 90,
            level: 5
        },
        'wooper': {
            terrain: 'WATER',
            type: 'WATER',
            secondaryType: 'GROUND',
            color: '#98D8D8',
            moves: ['Tackle', 'Water Gun', 'Mud Slap'],
            sprite: [
                '  ██████    ',
                ' ██░░░░██   ',
                '██░░░░░░██  ',
                ' ████████   '
            ],
            hp: 55,
            attack: 45,
            defense: 45,
            speed: 15,
            level: 4
        },
        'lotad': {
            terrain: 'WATER',
            type: 'WATER',
            secondaryType: 'GRASS',
            color: '#6890F0',
            moves: ['Tackle', 'Water Gun'],
            sprite: [
                '   ██████   ',
                '  ██░░░░██  ',
                ' ██░░░░░░██ ',
                '  ██░░░░██  ',
                '   ██████   '
            ],
            hp: 40,
            attack: 30,
            defense: 30,
            speed: 30,
            level: 3
        },
        'treecko': {
            terrain: 'LAB',
            type: 'GRASS',
            secondaryType: null,
            color: '#32CD32',
            moves: ['Tackle', 'Vine Whip'],
            sprite: [
                '   ██████   ',
                '  ██░░░░██  ',
                ' ██░░░░░░██ ',
                '  ██░░░░██  ',
                '   ██████   ',
                '    ████    '
            ],
            hp: 40,
            attack: 45,
            defense: 35,
            speed: 70,
            level: 5
        },
        'froakie': {
            terrain: 'LAB',
            type: 'WATER',
            secondaryType: null,
            color: '#1E90FF',
            moves: ['Tackle', 'Water Gun'],
            sprite: [
                '  ████████  ',
                ' ██░░░░░░██ ',
                '██░░░░░░░░██',
                ' ██████████ '
            ],
            hp: 41,
            attack: 56,
            defense: 40,
            speed: 71,
            level: 5
        },
        'charmander': {
            terrain: 'LAB',
            type: 'FIRE',
            secondaryType: null,
            color: '#FF4500',
            moves: ['Tackle', 'Ember'],
            sprite: [
                '    ████    ',
                '   ██░░██   ',
                '  ██░░░░██  ',
                ' ██░░░░░░██ ',
                '  ████████  '
            ],
            hp: 39,
            attack: 52,
            defense: 43,
            speed: 65,
            level: 5
        }
    };

    // Wild Pokémon array
    let wildPokemon = [];
    let activeWildPokemon = null;
    let battleState = null;

    // Terrain boundaries (strict for spawning)
    const terrainBounds = {
        'GRASS': { 
            x: width - 450, 
            y: 50, 
            width: 12*40, 
            height: 8*40,
            color: '#567d56',
            name: 'Grassland'
        },
        'ROCKY': { 
            x: 0, 
            y: height/2 + 120, 
            width: width, 
            height: height/2,
            color: '#e5d17c',
            name: 'Rocky Terrain'
        },
        'WATER': { 
            x: width/2 - 350, 
            y: height/2 - 50, 
            width: 290, 
            height: 190,
            color: '#1e5aab',
            name: 'Pond'
        }
    };

    // Rock positions
    const rocks = [];
    function generateRocks() {
        rocks.length = 0;
        for(let i=0; i<30; i++) {
            rocks.push({
                x: Math.random() * 2000, 
                y: 500 + Math.random() * 500,
                size: 15 + Math.random() * 25,
                color: Math.random() > 0.5 ? '#c5b16c' : '#b5a15c'
            });
        }
    }

    function resize() {
        width = window.innerWidth; height = window.innerHeight;
        canvas.width = width; canvas.height = height;
        
        // Update terrain bounds with actual screen dimensions
        terrainBounds.GRASS = { 
            x: width - 450, 
            y: 50, 
            width: 12*40, 
            height: 8*40,
            color: '#567d56',
            name: 'Grassland'
        };
        terrainBounds.ROCKY = { 
            x: 0, 
            y: height/2 + 120, 
            width: width, 
            height: height/2,
            color: '#e5d17c',
            name: 'Rocky Terrain'
        };
        terrainBounds.WATER = { 
            x: width/2 - 350, 
            y: height/2 - 50, 
            width: 290, 
            height: 190,
            color: '#1e5aab',
            name: 'Pond'
        };
        
        generateRocks();
        spawnWildPokemon();
    }
    window.addEventListener('resize', resize);
    resize();

    const player = { x: width/2, y: height - 120, speed: 5, history: [] };
    const follower = { 
        active: false, 
        name: '', 
        x: 0, 
        y: 0, 
        color: '#000', 
        hp: 100, 
        maxHp: 100, 
        level: 5,
        moves: ['Tackle'],
        type: 'NORMAL',
        attack: 50,
        defense: 50,
        speed: 50
    };

    const pokeballs = [
        { name: 'Treecko', x: 0, y: 0, color: '#32CD32', active: true },
        { name: 'Froakie', x: 0, y: 0, color: '#1E90FF', active: true },
        { name: 'Charmander', x: 0, y: 0, color: '#FF4500', active: true }
    ];

    // Enhanced spawn function with STRICT terrain boundaries
    function spawnWildPokemon() {
        wildPokemon = [];
        if (currentMap === 'OUTSIDE') {
            // Clear any existing terrain indicators
            document.querySelectorAll('.terrain-indicator').forEach(el => el.remove());
            
            // Spawn grass Pokémon ONLY in grass terrain
            const grassBounds = terrainBounds.GRASS;
            for (let i = 0; i < 4; i++) {
                const grassPokemon = Object.entries(pokemonDatabase)
                    .filter(([name, data]) => data.terrain === 'GRASS');
                const randomPoke = grassPokemon[Math.floor(Math.random() * grassPokemon.length)];
                
                // Ensure spawn is within grass bounds
                const x = grassBounds.x + 20 + Math.random() * (grassBounds.width - 40);
                const y = grassBounds.y + 20 + Math.random() * (grassBounds.height - 40);
                
                const pokemon = {
                    name: randomPoke[0],
                    ...randomPoke[1],
                    x: x,
                    y: y,
                    active: true,
                    terrain: 'GRASS'
                };
                
                wildPokemon.push(pokemon);
                
                // Add terrain indicator (visual only, can remove if not wanted)
                const indicator = document.createElement('div');
                indicator.className = 'terrain-indicator';
                indicator.style.left = `${x - 30}px`;
                indicator.style.top = `${y - 40}px`;
                indicator.textContent = 'Grass';
                indicator.style.color = '#78C850';
                document.getElementById('game-wrapper').appendChild(indicator);
            }
            
            // Spawn rocky Pokémon ONLY in rocky terrain
            const rockyBounds = terrainBounds.ROCKY;
            for (let i = 0; i < 4; i++) {
                const rockyPokemon = Object.entries(pokemonDatabase)
                    .filter(([name, data]) => data.terrain === 'ROCKY');
                const randomPoke = rockyPokemon[Math.floor(Math.random() * rockyPokemon.length)];
                
                // Ensure spawn is within rocky bounds (avoid edges)
                const x = rockyBounds.x + 50 + Math.random() * (rockyBounds.width - 100);
                const y = rockyBounds.y + 50 + Math.random() * (rockyBounds.height - 100);
                
                const pokemon = {
                    name: randomPoke[0],
                    ...randomPoke[1],
                    x: x,
                    y: y,
                    active: true,
                    terrain: 'ROCKY'
                };
                
                wildPokemon.push(pokemon);
                
                // Add terrain indicator
                const indicator = document.createElement('div');
                indicator.className = 'terrain-indicator';
                indicator.style.left = `${x - 40}px`;
                indicator.style.top = `${y - 40}px`;
                indicator.textContent = 'Rocks';
                indicator.style.color = '#B8A038';
                document.getElementById('game-wrapper').appendChild(indicator);
            }
            
            // Spawn water Pokémon ONLY in water terrain
            const waterBounds = terrainBounds.WATER;
            for (let i = 0; i < 3; i++) {
                const waterPokemon = Object.entries(pokemonDatabase)
                    .filter(([name, data]) => data.terrain === 'WATER');
                const randomPoke = waterPokemon[Math.floor(Math.random() * waterPokemon.length)];
                
                // Generate points within the oval pond (avoid edges)
                const angle = Math.random() * Math.PI * 2;
                const xRadius = waterBounds.width / 2 * 0.8; // 80% of radius to stay inside
                const yRadius = waterBounds.height / 2 * 0.8;
                
                const x = waterBounds.x + waterBounds.width/2 + Math.cos(angle) * xRadius;
                const y = waterBounds.y + waterBounds.height/2 + Math.sin(angle) * yRadius;
                
                const pokemon = {
                    name: randomPoke[0],
                    ...randomPoke[1],
                    x: x,
                    y: y,
                    active: true,
                    terrain: 'WATER'
                };
                
                wildPokemon.push(pokemon);
                
                // Add terrain indicator
                const indicator = document.createElement('div');
                indicator.className = 'terrain-indicator';
                indicator.style.left = `${x - 30}px`;
                indicator.style.top = `${y - 40}px`;
                indicator.textContent = 'Water';
                indicator.style.color = '#6890F0';
                document.getElementById('game-wrapper').appendChild(indicator);
            }
            
            console.log(`Spawned ${wildPokemon.length} Pokémon in their respective terrains`);
        }
    }

    // Draw Pokémon sprite
    function drawPokemonSprite(pokemon, x, y, size = 1, context = ctx) {
        const sprite = pokemon.sprite || pokemonDatabase[pokemon.name]?.sprite;
        if (!sprite) return;
        
        const color = pokemon.color || pokemonDatabase[pokemon.name]?.color;
        if (!color) return;
        
        context.fillStyle = color;
        for (let row = 0; row < sprite.length; row++) {
            for (let col = 0; col < sprite[row].length; col++) {
                if (sprite[row][col] === '█') {
                    context.fillRect(x + col * size, y + row * size, size, size);
                } else if (sprite[row][col] === '░') {
                    context.fillStyle = '#FFFFFF';
                    context.fillRect(x + col * size, y + row * size, size, size);
                    context.fillStyle = color;
                }
            }
        }
    }

    function toggleBag(open) {
        if (inBattle || pendingEncounter) return;
        isBagOpen = open;
        bagMenu.style.display = open ? 'block' : 'none';
        if (open) {
            const content = document.getElementById('bag-content');
            content.innerHTML = `
                <div class="bag-item"><span>Partner:</span> <strong>${follower.active ? follower.name : 'None'}</strong></div>
                <div class="bag-item"><span>Potions:</span> <strong>x${playerInventory.potions}</strong> <button onclick="usePotion()" style="margin-left:10px; padding:5px 10px; background:#4CAF50; color:white; border:none; border-radius:3px;">Use</button></div>
                <div class="bag-item"><span>Pokéballs:</span> <strong>x${playerInventory.pokeballs}</strong></div>
                <div class="bag-item"><span>Captured:</span> <strong>${playerInventory.capturedPokemon.length} Pokémon</strong></div>
                <hr style="margin:10px 0;">
                ${playerInventory.capturedPokemon.map(poke => `
                    <div class="bag-item"><span>${poke}</span> <span class="type-${pokemonDatabase[poke]?.type.toLowerCase()} battle-type-tag">${pokemonDatabase[poke]?.type || '???'}</span></div>
                `).join('')}
            `;
        }
    }

    function usePotion() {
        if (playerInventory.potions > 0 && follower.active) {
            const healAmount = Math.floor(follower.maxHp * 0.5);
            follower.hp = Math.min(follower.maxHp, follower.hp + healAmount);
            playerInventory.potions--;
            toggleBag(false);
            // Show healing effect
            showFloatingText(`+${healAmount} HP`, follower.x, follower.y, '#00FF00');
        }
    }

    function showFloatingText(text, x, y, color) {
        const textDiv = document.createElement('div');
        textDiv.textContent = text;
        textDiv.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            color: ${color};
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            z-index: 10000;
            animation: floatUp 1s forwards;
        `;
        
        const style = document.createElement('style');
        style.textContent = `
            @keyframes floatUp {
                0% { transform: translateY(0); opacity: 1; }
                100% { transform: translateY(-50px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(textDiv);
        setTimeout(() => textDiv.remove(), 1000);
    }

    function startGame() {
        titleScreen.style.opacity = '0';
        setTimeout(() => {
            titleScreen.style.display = 'none';
            uiLayer.style.display = 'block';
        }, 500);
    }

    let stickX = 0, stickY = 0, isTouching = false;

    function handleDialogueClick() {
        if (scriptIndex < script.length - 1) {
            scriptIndex++;
            dialogueBox.innerText = script[scriptIndex];
        } else {
            uiLayer.style.display = 'none';
            choosingState = true;
        }
    }

    canvas.addEventListener('mousedown', (e) => checkPokeClick(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', (e) => checkPokeClick(e.touches[0].clientX, e.touches[0].clientY));

    function checkPokeClick(clickX, clickY) {
        if (inBattle || isBagOpen || pendingEncounter) return;
        
        if (!choosingState || follower.active || currentMap !== 'LAB') {
            // Check for wild Pokémon encounters
            wildPokemon.forEach(poke => {
                if (!poke.active) return;
                const dx = clickX - poke.x;
                const dy = clickY - poke.y;
                if (Math.sqrt(dx*dx + dy*dy) < 40) {
                    // Show encounter alert instead of starting battle immediately
                    showEncounterAlert(poke);
                }
            });
            return;
        }
        
        pokeballs.forEach(ball => {
            if(!ball.active) return;
            const dx = clickX - ball.realX;
            const dy = clickY - ball.realY;
            if (Math.sqrt(dx*dx + dy*dy) < 40) {
                follower.active = true; 
                follower.name = ball.name;
                const pokemonData = pokemonDatabase[ball.name.toLowerCase()];
                follower.color = pokemonData.color;
                follower.x = ball.realX;
                follower.y = ball.realY; 
                follower.hp = pokemonData.hp;
                follower.maxHp = pokemonData.hp;
                follower.level = pokemonData.level;
                follower.moves = pokemonData.moves;
                follower.type = pokemonData.type;
                follower.attack = pokemonData.attack;
                follower.defense = pokemonData.defense;
                follower.speed = pokemonData.speed;
                ball.active = false;
                holdingPokeball = true;
            }
        });
    }

    // Show encounter alert with choice
    function showEncounterAlert(wildPoke) {
        if (pendingEncounter || inBattle) return;
        
        pendingEncounter = wildPoke;
        document.getElementById('encounter-pokemon-name').textContent = wildPoke.name;
        encounterAlert.style.display = 'block';
    }

    function startBattleFromEncounter() {
        if (!pendingEncounter) return;
        
        encounterAlert.style.display = 'none';
        startBattle(pendingEncounter);
        pendingEncounter = null;
    }

    function avoidEncounter() {
        if (!pendingEncounter) return;
        
        // Make the Pokémon inactive for a short time
        pendingEncounter.active = false;
        setTimeout(() => {
            pendingEncounter.active = true;
        }, 5000); // Reactivate after 5 seconds
        
        encounterAlert.style.display = 'none';
        pendingEncounter = null;
        
        // Show avoidance message
        showFloatingText('Avoided!', player.x, player.y - 30, '#FFA500');
    }

    wrapper.addEventListener('touchstart', (e) => { isTouching = true; e.preventDefault(); });
    window.addEventListener('touchend', () => { isTouching = false; stickX = 0; stickY = 0; knob.style.transform = `translate(0px, 0px)`; });
    window.addEventListener('touchmove', (e) => {
        if (!isTouching) return;
        const rect = wrapper.getBoundingClientRect();
        const touch = e.touches[0];
        let dx = touch.clientX - (rect.left + rect.width/2);
        let dy = touch.clientY - (rect.top + rect.height/2);
        const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
        const angle = Math.atan2(dy, dx);
        stickX = Math.cos(angle) * (dist/40); stickY = Math.sin(angle) * (dist/40);
        knob.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
    });

    function checkCollision(nx, ny) {
        if (currentMap === 'LAB') {
            const dW = 350, dH = 100, dX = width/2 - dW/2, dY = height/2.5;
            if (nx > dX - 15 && nx < dX + dW + 15 && ny > dY - 15 && ny < dY + dH + 15) return true;
            if (ny < 130) return true;
        } else {
            const hX = width/2 - 110, hY = height/2 - 150;
            if (nx > hX - 20 && nx < hX + 240 && ny > hY - 60 && ny < hY + 150) {
                if (Math.abs(nx - width/2) < 30 && ny > hY + 100) return false;
                return true;
            }
            if (ny > height/2 + 120 && ny < height/2 + 130) {
                if (Math.abs(nx - width/2) > 40) return true;
            }
        }
        return false;
    }

    let isTeleporting = false;
    function teleport() {
        if (isTeleporting || pendingEncounter) return;
        isTeleporting = true;
        const shim = document.getElementById('shimmer');
        shim.style.opacity = '1';
        setTimeout(() => {
            currentMap = (currentMap === 'LAB') ? 'OUTSIDE' : 'LAB';
            player.x = width/2;
            player.y = (currentMap === 'OUTSIDE') ? height/2 + 80 : height - 120;
            player.history = [];
            spawnWildPokemon();
            shim.style.opacity = '0';
            isTeleporting = false;
        }, 300);
    }

    // Enhanced Battle System with proper turn-based mechanics
    function startBattle(wildPoke) {
        inBattle = true;
        activeWildPokemon = wildPoke;
        battleState = {
            wildHp: wildPoke.hp,
            wildMaxHp: wildPoke.hp,
            playerHp: follower.hp,
            playerMaxHp: follower.maxHp,
            playerTurn: true,
            environment: wildPoke.terrain,
            turn: 0,
            waitingForPlayer: true,
            messageQueue: []
        };
        
        // Hide move selector initially
        document.getElementById('move-selector').style.display = 'none';
        
        // Update battle UI
        document.getElementById('player-status').textContent = `Lv. ${follower.level}`;
        document.getElementById('wild-status').textContent = `Lv. ${wildPoke.level}`;
        
        // Update type tags
        const playerType = document.getElementById('player-type');
        const wildType = document.getElementById('wild-type');
        playerType.innerHTML = `<span class="type-${follower.type.toLowerCase()} battle-type-tag">${follower.type}</span>`;
        wildType.innerHTML = `<span class="type-${wildPoke.type.toLowerCase()} battle-type-tag">${wildPoke.type}</span>`;
        
        updateBattleHP();
        
        // Draw battle sprites
        updateBattleSprites();
        
        battleUI.style.display = 'block';
        
        // Start with battle message
        addBattleMessage(`A wild ${wildPoke.name} appeared!`);
        setTimeout(() => {
            addBattleMessage(`Go! ${follower.name}!`);
            setTimeout(() => {
                addBattleMessage(`What will ${follower.name} do?`);
            }, 1500);
        }, 1500);
        
        // Enable fight button after intro
        setTimeout(() => {
            document.getElementById('fight-btn').disabled = false;
            document.getElementById('bag-btn-battle').disabled = false;
            document.getElementById('pokemon-btn').disabled = false;
            document.getElementById('run-btn').disabled = false;
        }, 3500);
    }

    function updateBattleHP() {
        const playerPercent = (battleState.playerHp / battleState.playerMaxHp) * 100;
        const wildPercent = (battleState.wildHp / battleState.wildMaxHp) * 100;
        
        document.getElementById('player-hp-text').textContent = `HP: ${battleState.playerHp}/${battleState.playerMaxHp}`;
        document.getElementById('wild-hp-text').textContent = `HP: ${battleState.wildHp}/${battleState.wildMaxHp}`;
        document.getElementById('player-hp-fill').style.width = `${playerPercent}%`;
        document.getElementById('wild-hp-fill').style.width = `${wildPercent}%`;
        
        // Change HP bar color based on HP level
        const playerFill = document.getElementById('player-hp-fill');
        const wildFill = document.getElementById('wild-hp-fill');
        
        playerFill.style.background = playerPercent > 50 ? 'linear-gradient(to right, #00cc00, #88ff88)' : 
                                     playerPercent > 20 ? 'linear-gradient(to right, #ffcc00, #ffff88)' : 
                                     'linear-gradient(to right, #cc0000, #ff8888)';
        
        wildFill.style.background = wildPercent > 50 ? 'linear-gradient(to right, #00cc00, #88ff88)' : 
                                   wildPercent > 20 ? 'linear-gradient(to right, #ffcc00, #ffff88)' : 
                                   'linear-gradient(to right, #cc0000, #ff8888)`;
    }

    function updateBattleSprites() {
        const playerCanvas = document.getElementById('player-battle-sprite');
        const playerCtx = playerCanvas.getContext('2d');
        const wildCanvas = document.getElementById('wild-battle-sprite');
        const wildCtx = wildCanvas.getContext('2d');
        
        // Clear canvases
        playerCtx.clearRect(0, 0, 200, 200);
        wildCtx.clearRect(0, 0, 200, 200);
        
        // Draw player Pokémon (centered)
        const playerPokeData = pokemonDatabase[follower.name.toLowerCase()];
        if (playerPokeData) {
            drawPokemonSprite(playerPokeData, 60, 60, 5, playerCtx);
        }
        
        // Draw wild Pokémon (centered)
        const wildPokeData = pokemonDatabase[activeWildPokemon.name];
        if (wildPokeData) {
            drawPokemonSprite(wildPokeData, 60, 60, 5, wildCtx);
        }
    }

    function addBattleMessage(message) {
        const battleText = document.getElementById('battle-text');
        battleText.textContent = message;
    }

    function showMoveSelector() {
        if (!battleState.playerTurn || !battleState.waitingForPlayer) return;
        
        const moveSelector = document.getElementById('move-selector');
        moveSelector.style.display = 'block';
        
        let movesHTML = '<h3 style="color:#ffcb05; margin-top:0; text-align:center;">Choose a Move:</h3>';
        movesHTML += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">';
        
        follower.moves.forEach(moveName => {
            const move = moveDatabase[moveName];
            if (move) {
                movesHTML += `
                    <div class="move-option" onclick="useMove('${moveName}')">
                        <div style="font-weight:bold;">${moveName}</div>
                        <span class="move-type type-${move.type.toLowerCase()}">${move.type}</span>
                        <div class="move-details">
                            Power: ${move.power} | Acc: ${move.accuracy}%
                        </div>
                    </div>
                `;
            }
        });
        
        movesHTML += '</div>';
        moveSelector.innerHTML = movesHTML;
    }

    function cancelMove() {
        document.getElementById('move-selector').style.display = 'none';
    }

    function useMove(moveName) {
        if (!battleState.playerTurn || !battleState.waitingForPlayer) return;
        
        document.getElementById('move-selector').style.display = 'none';
        
        // Disable buttons during turn
        document.getElementById('fight-btn').disabled = true;
        document.getElementById('bag-btn-battle').disabled = true;
        document.getElementById('pokemon-btn').disabled = true;
        document.getElementById('run-btn').disabled = true;
        
        battleState.waitingForPlayer = false;
        battleState.turn++;
        
        const move = moveDatabase[moveName];
        
        // Player's turn
        executePlayerMove(moveName, move);
        
        // After player move, if wild Pokémon is still alive, wild attacks
        if (battleState.wildHp > 0) {
            setTimeout(() => {
                executeWildMove();
            }, 2000);
        }
    }

    function executePlayerMove(moveName, move) {
        // Animation: Player Pokémon attacks
        animateAttack('player');
        
        setTimeout(() => {
            // Check accuracy
            if (Math.random() * 100 > move.accuracy) {
                addBattleMessage(`${follower.name}'s ${moveName} missed!`);
                return;
            }
            
            // Calculate damage with type effectiveness
            const playerAttack = follower.attack;
            const wildDefense = activeWildPokemon.defense;
            const typeEffect = calculateTypeEffectiveness(move.type, activeWildPokemon.type, activeWildPokemon.secondaryType);
            
            let damage = Math.floor((((2 * follower.level) / 5 + 2) * move.power * (playerAttack / wildDefense)) / 50 + 2);
            damage = Math.floor(damage * typeEffect.multiplier);
            
            // Critical hit chance (1/16)
            let isCritical = false;
            if (Math.random() < 0.0625) {
                damage = Math.floor(damage * 1.5);
                isCritical = true;
            }
            
            // Apply damage
            battleState.wildHp = Math.max(0, battleState.wildHp - damage);
            
            // Animation: Wild Pokémon takes damage
            animateDamage('wild');
            
            // Update HP display
            updateBattleHP();
            
            // Build message
            let message = `${follower.name} used ${moveName}!`;
            if (isCritical) message += " Critical hit!";
            if (typeEffect.multiplier > 1) message += " It's super effective!";
            if (typeEffect.multiplier < 1) message += " It's not very effective...";
            message += `\nDealt ${damage} damage!`;
            
            addBattleMessage(message);
            
            // Check if wild Pokémon fainted
            if (battleState.wildHp <= 0) {
                setTimeout(() => {
                    addBattleMessage(`Wild ${activeWildPokemon.name} fainted!`);
                    setTimeout(() => {
                        attemptCapture();
                    }, 2000);
                }, 1500);
            }
        }, 500);
    }

    function executeWildMove() {
        // Animation: Wild Pokémon attacks
        animateAttack('wild');
        
        setTimeout(() => {
            // Select a random move
            const moves = activeWildPokemon.moves;
            const moveName = moves[Math.floor(Math.random() * moves.length)];
            const move = moveDatabase[moveName] || moveDatabase['Tackle'];
            
            // Check accuracy
            if (Math.random() * 100 > move.accuracy) {
                addBattleMessage(`Wild ${activeWildPokemon.name}'s ${moveName} missed!`);
                endTurn();
                return;
            }
            
            // Calculate damage with type effectiveness
            const wildAttack = activeWildPokemon.attack;
            const playerDefense = follower.defense;
            const typeEffect = calculateTypeEffectiveness(move.type, follower.type);
            
            let damage = Math.floor((((2 * activeWildPokemon.level) / 5 + 2) * move.power * (wildAttack / playerDefense)) / 50 + 2);
            damage = Math.floor(damage * typeEffect.multiplier);
            
            // Critical hit chance
            let isCritical = false;
            if (Math.random() < 0.0625) {
                damage = Math.floor(damage * 1.5);
                isCritical = true;
            }
            
            // Apply damage
            battleState.playerHp = Math.max(0, battleState.playerHp - damage);
            follower.hp = battleState.playerHp;
            
            // Animation: Player Pokémon takes damage
            animateDamage('player');
            
            // Update HP display
            updateBattleHP();
            
            // Build message
            let message = `Wild ${activeWildPokemon.name} used ${moveName}!`;
            if (isCritical) message += " Critical hit!";
            if (typeEffect.multiplier > 1) message += " It's super effective!";
            if (typeEffect.multiplier < 1) message += " It's not very effective...";
            message += `\nDealt ${damage} damage!`;
            
            addBattleMessage(message);
            
            // Check if player Pokémon fainted
            if (battleState.playerHp <= 0) {
                setTimeout(() => {
                    addBattleMessage(`${follower.name} fainted!`);
                    setTimeout(endBattle, 2000);
                }, 1500);
            } else {
                // End turn and allow player to make next move
                setTimeout(endTurn, 1500);
            }
        }, 500);
    }

    function endTurn() {
        battleState.playerTurn = true;
        battleState.waitingForPlayer = true;
        
        // Re-enable buttons
        document.getElementById('fight-btn').disabled = false;
        document.getElementById('bag-btn-battle').disabled = false;
        document.getElementById('pokemon-btn').disabled = false;
        document.getElementById('run-btn').disabled = false;
        
        addBattleMessage(`What will ${follower.name} do?`);
    }

    function animateAttack(attacker) {
        const side = attacker === 'player' ? 'player-side' : 'wild-side';
        const element = document.getElementById(side);
        
        // Simple attack animation
        element.style.transform = 'translateX(20px)';
        setTimeout(() => {
            element.style.transform = 'translateX(0px)';
        }, 300);
        
        // Create attack effect
        const effect = document.createElement('div');
        effect.className = 'battle-animation';
        effect.style.cssText = `
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            left: ${attacker === 'player' ? '300px' : 'calc(100% - 200px)'};
            top: ${attacker === 'player' ? '250px' : '150px'};
            animation: expand 0.5s forwards;
        `;
        
        const style = document.createElement('style');
        style.textContent = `
            @keyframes expand {
                0% { transform: scale(0.5); opacity: 1; }
                100% { transform: scale(2); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.getElementById('battle-screen').appendChild(effect);
        setTimeout(() => effect.remove(), 500);
    }

    function animateDamage(target) {
        const side = target === 'player' ? 'player-side' : 'wild-side';
        const element = document.getElementById(side);
        
        // Damage flash animation
        let flashes = 0;
        const flashInterval = setInterval(() => {
            element.style.opacity = flashes % 2 === 0 ? '0.5' : '1';
            flashes++;
            if (flashes > 5) {
                clearInterval(flashInterval);
                element.style.opacity = '1';
            }
        }, 100);
    }

    function calculateTypeEffectiveness(attackType, defenseType, secondaryType = null) {
        let multiplier = 1;
        let message = '';
        
        // Check primary type
        if (typeEffectiveness[attackType]) {
            if (typeEffectiveness[attackType].strong.includes(defenseType)) {
                multiplier *= 2;
                message = 'super effective';
            }
            if (typeEffectiveness[attackType].weak.includes(defenseType)) {
                multiplier *= 0.5;
                message = 'not very effective';
            }
        }
        
        // Check secondary type
        if (secondaryType && typeEffectiveness[attackType]) {
            if (typeEffectiveness[attackType].strong.includes(secondaryType)) {
                multiplier *= 2;
                message = 'super effective';
            }
            if (typeEffectiveness[attackType].weak.includes(secondaryType)) {
                multiplier *= 0.5;
                message = 'not very effective';
            }
        }
        
        return { multiplier, message };
    }

    function battleAction(action) {
        if (!battleState.playerTurn || !battleState.waitingForPlayer) return;
        
        const battleText = document.getElementById('battle-text');
        
        switch(action) {
            case 'bag':
                if (playerInventory.pokeballs > 0) {
                    battleText.textContent = `Used a Pokéball!`;
                    playerInventory.pokeballs--;
                    attemptCapture();
                } else {
                    battleText.textContent = `No Pokéballs left!`;
                }
                break;
                
            case 'run':
                // Calculate escape chance based on speed
                const escapeChance = follower.speed > activeWildPokemon.speed ? 0.9 : 0.5;
                if (Math.random() < escapeChance) {
                    battleText.textContent = `Got away safely!`;
                    setTimeout(endBattle, 1000);
                } else {
                    battleText.textContent = `Couldn't escape!`;
                    // Wild attacks after failed escape
                    setTimeout(() => {
                        executeWildMove();
                    }, 1000);
                }
                break;
                
            case 'pokemon':
                battleText.textContent = `You only have one Pokémon!`;
                break;
        }
    }

    function attemptCapture() {
        const captureChance = (battleState.wildHp / battleState.wildMaxHp) < 0.3 ? 0.9 : 
                             (battleState.wildHp / battleState.wildMaxHp) < 0.5 ? 0.7 : 
                             (battleState.wildHp / battleState.wildMaxHp) < 0.7 ? 0.5 : 0.3;
        
        // Pokéball animation
        addBattleMessage(`You threw a Pokéball!`);
        
        setTimeout(() => {
            if (Math.random() < captureChance) {
                addBattleMessage(`Gotcha! ${activeWildPokemon.name} was caught!`);
                playerInventory.capturedPokemon.push(activeWildPokemon.name);
                
                // Remove from wild encounters
                wildPokemon = wildPokemon.filter(poke => poke !== activeWildPokemon);
                setTimeout(() => {
                    addBattleMessage(`${activeWildPokemon.name} was added to your Pokédex!`);
                }, 1000);
            } else {
                addBattleMessage(`Oh no! The Pokémon broke free!`);
            }
            
            setTimeout(endBattle, 2000);
        }, 1500);
    }

    function endBattle() {
        inBattle = false;
        activeWildPokemon = null;
        battleState = null;
        battleUI.style.display = 'none';
        document.getElementById('move-selector').style.display = 'none';
        
        // Clear any terrain indicators that might have been added
        document.querySelectorAll('.battle-animation').forEach(el => el.remove());
    }

    function update() {
        if (isBagOpen || inBattle || pendingEncounter) return;
        if (isTouching) {
            let nextX = player.x + stickX * player.speed;
            let nextY = player.y + stickY * player.speed;
            if (!checkCollision(nextX, nextY)) {
                player.history.push({x: player.x, y: player.y});
                if (player.history.length > 60) player.history.shift();
                player.x = nextX; player.y = nextY;
            }
            
            // Check for random encounters based on terrain
            if (currentMap === 'OUTSIDE' && !pendingEncounter) {
                let encounterChance = 0.001; // Base chance
                
                // Determine which terrain player is in
                let currentTerrain = null;
                
                // Check grass terrain
                const grassBounds = terrainBounds.GRASS;
                if (player.x >= grassBounds.x && player.x <= grassBounds.x + grassBounds.width &&
                    player.y >= grassBounds.y && player.y <= grassBounds.y + grassBounds.height) {
                    currentTerrain = 'GRASS';
                    encounterChance = 0.003; // Higher chance in grass
                }
                
                // Check rocky terrain
                const rockyBounds = terrainBounds.ROCKY;
                if (player.x >= rockyBounds.x && player.x <= rockyBounds.x + rockyBounds.width &&
                    player.y >= rockyBounds.y && player.y <= rockyBounds.y + rockyBounds.height) {
                    currentTerrain = 'ROCKY';
                    encounterChance = 0.002;
                }
                
                // Check water terrain (only if very close to pond)
                const waterBounds = terrainBounds.WATER;
                const dx = player.x - (waterBounds.x + waterBounds.width/2);
                const dy = player.y - (waterBounds.y + waterBounds.height/2);
                const distanceFromCenter = Math.sqrt(dx*dx + dy*dy);
                if (distanceFromCenter < 100) { // Only trigger near water
                    currentTerrain = 'WATER';
                    encounterChance = 0.002;
                }
                
                // Random encounter check
                if (currentTerrain && Math.random() < encounterChance) {
                    // Find Pokémon in the same terrain
                    const terrainPokemon = wildPokemon.filter(poke => 
                        poke.active && 
                        poke.terrain === currentTerrain &&
                        Math.abs(poke.x - player.x) < 200 && 
                        Math.abs(poke.y - player.y) < 200
                    );
                    
                    if (terrainPokemon.length > 0) {
                        const randomPokemon = terrainPokemon[Math.floor(Math.random() * terrainPokemon.length)];
                        showEncounterAlert(randomPokemon);
                    }
                }
            }
        }
        const matX = width / 2;
        const matY = (currentMap === 'LAB') ? height - 30 : height / 2 + 10;
        if (Math.abs(player.x - matX) < 50 && Math.abs(player.y - matY) < 30) teleport();
        
        if (follower.active && player.history.length > 12) {
            const fp = player.history[player.history.length - 12];
            follower.x += (fp.x - follower.x) * 0.15; follower.y += (fp.y - follower.y) * 0.15;
        }
        player.x = Math.max(20, Math.min(width-20, player.x));
        player.y = Math.max(20, Math.min(height-20, player.y));
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        if (currentMap === 'LAB') {
            ctx.fillStyle = '#d89060'; ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = '#b87040'; for(let i=0; i<width; i+=60) ctx.strokeRect(i, 0, 60, height);
            ctx.fillStyle = '#3a8fb7'; ctx.fillRect(width/2 - 50, height - 50, 100, 50);
            ctx.strokeStyle = '#ffcb05'; ctx.lineWidth = 3; ctx.strokeRect(width/2 - 50, height - 50, 100, 50);
            ctx.fillStyle = '#5d3a1a'; for(let i=50; i<width-100; i+=120) ctx.fillRect(i, 20, 100, 100);
            ctx.fillStyle = '#8b4513'; ctx.fillRect(20, height - 100, 30, 30); ctx.fillRect(width - 50, height - 100, 30, 30);
            ctx.fillStyle = '#228b22'; ctx.beginPath(); ctx.arc(35, height-110, 20, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(width-35, height-110, 20, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#444'; ctx.fillRect(width - 150, 130, 120, 60);

            const dW = 350, dH = 100, dX = width/2 - dW/2, dY = height/2.5;
            ctx.fillStyle = '#804020'; ctx.fillRect(dX, dY, dW, dH);
            pokeballs.forEach((ball, i) => {
                if (!ball.active) return;
                ball.realX = dX + 60 + (i * 110); ball.realY = dY + 40;
                ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(ball.realX, ball.realY, 15, Math.PI, 0); ctx.fill();
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(ball.realX, ball.realY, 15, 0, Math.PI); ctx.fill();
                ctx.fillStyle = '#ffcb05'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.fillText(ball.name.toUpperCase(), ball.realX, ball.realY - 30);
            });
        } else {
            // Draw background with gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#8acd8a');
            gradient.addColorStop(0.5, '#719e71');
            gradient.addColorStop(1, '#567d56');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Draw wild Pokémon in their respective terrains
            wildPokemon.forEach(poke => {
                if (poke.active) {
                    drawPokemonSprite(poke, poke.x - 15, poke.y - 15, 2);
                }
            });
            
            // GRASS TERRAIN (with strict boundaries)
            ctx.fillStyle = terrainBounds.GRASS.color; 
            ctx.fillRect(terrainBounds.GRASS.x, terrainBounds.GRASS.y, 
                        terrainBounds.GRASS.width, terrainBounds.GRASS.height);
            
            // Draw grass pattern
            ctx.fillStyle = '#4a6d4a';
            for(let row=0; row<8; row++) {
                for(let col=0; col<12; col++) {
                    let gx = terrainBounds.GRASS.x + col*40;
                    let gy = terrainBounds.GRASS.y + row*40;
                    if (gx < terrainBounds.GRASS.x + terrainBounds.GRASS.width && 
                        gy < terrainBounds.GRASS.y + terrainBounds.GRASS.height) {
                        // Draw grass blades
                        for(let i=0; i<5; i++) {
                            const bladeX = gx + Math.random() * 35;
                            const bladeY = gy + Math.random() * 35;
                            ctx.fillRect(bladeX, bladeY, 1, 3 + Math.random() * 5);
                        }
                    }
                }
            }

            // ROCKY TERRAIN (with strict boundaries)
            const rockGradient = ctx.createLinearGradient(0, terrainBounds.ROCKY.y, 0, height);
            rockGradient.addColorStop(0, terrainBounds.ROCKY.color);
            rockGradient.addColorStop(1, '#c5b16c');
            ctx.fillStyle = rockGradient;
            ctx.fillRect(terrainBounds.ROCKY.x, terrainBounds.ROCKY.y, 
                        terrainBounds.ROCKY.width, terrainBounds.ROCKY.height);
            
            rocks.forEach(rock => {
                // Ensure rocks only appear in rocky terrain
                const rockX = rock.x % width;
                const rockY = (rock.y % (terrainBounds.ROCKY.height/2)) + terrainBounds.ROCKY.y;
                
                if (rockY >= terrainBounds.ROCKY.y && rockY <= height) {
                    ctx.fillStyle = rock.color;
                    ctx.beginPath();
                    ctx.moveTo(rockX, rockY);
                    ctx.lineTo(rockX + rock.size, rockY);
                    ctx.lineTo(rockX + rock.size/2, rockY - rock.size);
                    ctx.closePath();
                    ctx.fill();
                }
            });

            // WATER TERRAIN (Pond) - strictly oval shaped
            const wX = terrainBounds.WATER.x + terrainBounds.WATER.width/2;
            const wY = terrainBounds.WATER.y + terrainBounds.WATER.height/2;
            
            // Water reflection effect
            const waterGradient = ctx.createRadialGradient(wX, wY, 0, wX, wY, terrainBounds.WATER.width/2);
            waterGradient.addColorStop(0, '#3a8fb7');
            waterGradient.addColorStop(0.7, terrainBounds.WATER.color);
            waterGradient.addColorStop(1, '#0a3a7b');
            
            ctx.fillStyle = waterGradient;
            ctx.beginPath();
            ctx.ellipse(wX, wY, terrainBounds.WATER.width/2, terrainBounds.WATER.height/2, 0, 0, Math.PI*2);
            ctx.fill();
            
            // Water ripple effect
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            for(let i=0; i<3; i++) {
                ctx.beginPath();
                ctx.ellipse(wX, wY, terrainBounds.WATER.width/3 + i*15, terrainBounds.WATER.height/3 + i*10, 0, 0, Math.PI*2);
                ctx.stroke();
            }

            // TREES (around the edges)
            ctx.fillStyle = '#1a331a';
            const fenceY = height/2 + 120;
            for(let x = 40; x < width; x += 80) {
                ctx.beginPath();
                ctx.arc(x, 40, 35, 0, Math.PI*2);
                ctx.fill();
                
                // Tree trunk
                ctx.fillStyle = '#3e2712';
                ctx.fillRect(x - 5, 40, 10, 80);
                ctx.fillStyle = '#1a331a';
                
                if (x < 100 || x > width - 100) {
                    for(let y = 120; y < fenceY - 40; y += 80) {
                        ctx.beginPath();
                        ctx.arc(x, y, 35, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Tree trunk
                        ctx.fillStyle = '#3e2712';
                        ctx.fillRect(x - 5, y, 10, 80);
                        ctx.fillStyle = '#1a331a';
                    }
                }
            }
            
            // FENCE (border between grass and rocky terrain)
            ctx.strokeStyle = '#3e2712'; ctx.lineWidth = 6;
            ctx.beginPath(); ctx.moveTo(0, fenceY); ctx.lineTo(width/2 - 45, fenceY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(width/2 + 45, fenceY); ctx.lineTo(width, fenceY); ctx.stroke();
            for(let x=0; x<width; x+=40) { 
                if(Math.abs(x - width/2) > 40) { 
                    ctx.beginPath(); 
                    ctx.moveTo(x, fenceY-10); 
                    ctx.lineTo(x, fenceY+15); 
                    ctx.stroke(); 
                } 
            }

            // HOUSE
            const hX = width/2 - 110, hY = height/2 - 150;
            const houseGradient = ctx.createLinearGradient(hX, hY, hX, hY + 150);
            houseGradient.addColorStop(0, '#b0d0e8');
            houseGradient.addColorStop(1, '#80a0c8');
            ctx.fillStyle = houseGradient;
            ctx.fillRect(hX, hY, 220, 150);
            
            // Roof
            ctx.fillStyle = '#e06060';
            ctx.beginPath();
            ctx.moveTo(hX-20, hY);
            ctx.lineTo(width/2, hY-60);
            ctx.lineTo(hX+240, hY);
            ctx.fill();
            
            // Door
            ctx.fillStyle = '#285088';
            ctx.fillRect(width/2 - 30, height/2 - 45, 60, 45);
            ctx.fillStyle = '#ffcb05';
            ctx.fillRect(width/2 - 20, height/2 - 25, 10, 10); // Door knob
        }

        if (follower.active) {
            drawPokemonSprite(pokemonDatabase[follower.name.toLowerCase()], follower.x - 15, follower.y - 15, 2);
        }

        // PLAYER
        ctx.fillStyle = '#333'; ctx.fillRect(player.x-15, player.y+15, 10, 10); ctx.fillRect(player.x+5, player.y+15, 10, 10);
        ctx.fillStyle = '#a03030'; ctx.fillRect(player.x-15, player.y-10, 30, 25);
        ctx.fillStyle = '#ffdbac'; ctx.fillRect(player.x-10, player.y-25, 20, 18);
        ctx.fillStyle = '#fff'; ctx.fillRect(player.x-12, player.y-30, 24, 8);
        ctx.fillStyle = '#000'; ctx.fillRect(player.x-6, player.y-18, 3, 3); ctx.fillRect(player.x+3, player.y-18, 3, 3);
        
        if (holdingPokeball) {
            ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(player.x + 15, player.y, 6, Math.PI, 0); ctx.fill();
            ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(player.x + 15, player.y, 6, 0, Math.PI); ctx.fill();
        }

        update();
        requestAnimationFrame(draw);
    }
    draw();
</script>
</body>
</html>
