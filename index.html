<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pokémon Game</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    * {
      font-family: 'Press Start 2P', cursive;
      box-sizing: border-box;
    }

    body {
      background-color: black;
      margin: 0;
      padding: 0;
    }

    h1 {
      margin: 0;
    }

    button {
      border: 0;
      cursor: pointer;
      font-size: 16px;
    }

    button:hover {
      background-color: #ddd;
    }

    #introScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: black;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #professorScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: black;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 20;
      color: white;
    }

    #dialogueBox {
      background-color: white;
      color: black;
      padding: 20px;
      margin-top: 20px;
      width: 80%;
      height: 100px;
      border: 4px solid black;
      position: absolute;
      bottom: 20px;
    }

    #nameInput {
      display: none;
      margin-top: 20px;
    }

    #startButton {
      display: none;
      margin-top: 20px;
    }

    #starterChoice {
      display: none;
      flex-direction: row;
      justify-content: space-around;
      width: 80%;
      margin-top: 20px;
    }

    .starter {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div style="display: inline-block; position: relative">
    <div id="overlappingDiv" style="background-color: black; position: absolute; top: 0; right: 0; bottom: 0; left: 0; opacity: 0; pointer-events: none; z-index: 10;"></div>

    <canvas></canvas>
    <div id="characterDialogueBox" style="background-color: white; height: 140px; position: absolute; bottom: 0; left: 0; right: 0; border-top: 4px black solid; display: none; padding: 12px;"></div>

    <div id="userInterface" style="display: none">
      <!-- Represents health bar of enemy -->
      <div style="background-color: white; width: 250px; position: absolute; top: 50px; left: 50px; border: 4px black solid; padding: 12px;">
        <h1 style="font-size: 16px" id="enemyName">Enemy</h1>
        <div style="position: relative">
          <div style="height: 5px; background-color: #ccc; margin-top: 10px"></div>
          <div id="enemyHealthBar" style="height: 5px; background-color: green; position: absolute; top: 0; left: 0; right: 0;"></div>
        </div>
      </div>

      <!-- Represents health bar of player -->
      <div style="background-color: white; width: 250px; position: absolute; top: 330px; right: 50px; border: 4px black solid; padding: 12px;">
        <h1 style="font-size: 16px" id="playerName">Player</h1>
        <div style="position: relative">
          <div style="height: 5px; background-color: #ccc; margin-top: 10px"></div>
          <div id="playerHealthBar" style="height: 5px; background-color: green; position: absolute; top: 0; left: 0; right: 0;"></div>
        </div>
      </div>

      <div style="background-color: white; height: 140px; position: absolute; bottom: 0; left: 0; right: 0; border-top: 4px black solid; display: flex;">
        <div id="dialogueBox" style="position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: white; padding: 12px; display: none; cursor: pointer;">
          sdkfjlsdajl
        </div>
        <div id="attacksBox" style="width: 66.66%; display: grid; grid-template-columns: repeat(2, 1fr);"></div>
        <div style="display: flex; align-items: center; justify-content: center; width: 33.33%; border-left: 4px black solid;">
          <h1 id="attackType" style="font-size: 16px">Attack Type</h1>
        </div>
      </div>
    </div>
  </div>

  <!-- Intro Screen -->
  <div id="introScreen">
    <img src="https://i.ytimg.com/vi/LR-n1Ek32WM/maxresdefault.jpg" alt="Pokémon Logo" style="max-width: 80%;"> 
  </div>

  <!-- Professor Screen -->
  <div id="professorScreen">
    <img id="professorImage" src="https://example.com/path/to/professor.png" alt="Professor" style="max-width: 200px;"> <!-- Replace with base64 or URL of uploaded professor sprite -->
    <div id="profDialogueBox" style="background-color: white; color: black; padding: 20px; margin-top: 20px; width: 80%; border: 4px solid black;"></div>
    <input id="nameInput" type="text" placeholder="Enter your name">
    <button id="startButton">Start</button>
    <div id="starterChoice">
      <img class="starter" data-starter="Treecko" src="https://media.printables.com/media/prints/480066/images/3925019_a1b88545-29b9-4cb8-823a-6c225b890c5a/thumbs/inside/1280x960/jpg/gen3-3.webp" alt="Treecko">
      <img class="starter" data-starter="Froakie" src="https://i.etsystatic.com/46257809/r/il/d111db/5417651263/il_fullxfull.5417651263_prk6.jpg" alt="Froakie">
      <img class="starter" data-starter="Charmander" src="https://art.pixilart.com/567849c20b695c6.png" alt="Charmander">
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js" integrity="sha512-6+YN/9o9BWrk6wSfGxQGpt3EUK6XeHi6yeHV+TYD2GR0Sj/cggRpXr1BrAQf0as6XslxomMUxXp2vIl+fv0QRA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js" integrity="sha512-H6cPm97FAsgIKmlBA4s774vqoN24V5gSQL4yBTDOY2su2DeXZVhQPxFK4P6GPdnZqM9fg1G3cMv5wD7e6cFLZQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    // audio.js
    const audio = {
      Map: new Howl({
        src: './audio/map.wav', // Replace with your audio paths
        html5: true,
        volume: 0.1
      }),
      initBattle: new Howl({
        src: './audio/initBattle.wav',
        html5: true,
        volume: 0.1
      }),
      battle: new Howl({
        src: './audio/battle.mp3',
        html5: true,
        volume: 0.1
      }),
      tackleHit: new Howl({
        src: './audio/tackleHit.wav',
        html5: true,
        volume: 0.1
      }),
      fireballHit: new Howl({
        src: './audio/fireballHit.wav',
        html5: true,
        volume: 0.1
      }),
      initFireball: new Howl({
        src: './audio/initFireball.wav',
        html5: true,
        volume: 0.1
      }),
      victory: new Howl({
        src: './audio/victory.wav',
        html5: true,
        volume: 0.1
      })
    };
  </script>

  <script>
    // battleZones.js - Modify for your map
    const battleZonesData = [
      // Your battle zones array here, similar to collisions
      // For example, positions where battles can occur
    ];
  </script>

  <script>
    // collisions.js - Modify for your house map
    const collisions = [
      // Define your collision array based on the house image
      // For example, 1025 for walls, 0 for walkable
      // Assume 70 width as in tutorial, adjust for your map size
    ];
  </script>

  <script>
    // attacks.js - Add more attacks as needed
    const attacks = {
      Tackle: {
        name: 'Tackle',
        damage: 10,
        type: 'Normal',
        color: 'black'
      },
      Fireball: {
        name: 'Fireball',
        damage: 25,
        type: 'Fire',
        color: 'red'
      }
      // Add more
    };
  </script>

  <script>
    // monsters.js - Change to your starters
    const monsters = {
      Treecko: {
        position: {
          x: 280,
          y: 325
        },
        image: {
          src: 'https://media.printables.com/media/prints/480066/images/3925019_a1b88545-29b9-4cb8-823a-6c225b890c5a/thumbs/inside/1280x960/jpg/gen3-3.webp' // Use better sprite
        },
        frames: {
          max: 4,
          hold: 30
        },
        animate: true,
        name: 'Treecko',
        attacks: [attacks.Tackle] // Add attacks
      },
      Froakie: {
        position: {
          x: 280,
          y: 325
        },
        image: {
          src: 'https://i.etsystatic.com/46257809/r/il/d111db/5417651263/il_fullxfull.5417651263_prk6.jpg'
        },
        frames: {
          max: 4,
          hold: 30
        },
        animate: true,
        name: 'Froakie',
        attacks: [attacks.Tackle]
      },
      Charmander: {
        position: {
          x: 280,
          y: 325
        },
        image: {
          src: 'https://art.pixilart.com/567849c20b695c6.png'
        },
        frames: {
          max: 4,
          hold: 30
        },
        animate: true,
        name: 'Charmander',
        attacks: [attacks.Tackle, attacks.Fireball]
      },
      // Add more for 25 Pokémon
    };
  </script>

  <script>
    // characters.js - Add professor
    const charactersMapData = [
      // Your characters positions, use 1026 for professor etc.
    ];
  </script>

  <script>
    // utils.js
    function rectangularCollision({ rectangle1, rectangle2 }) {
      return (
        rectangle1.position.x + rectangle1.width >= rectangle2.position.x &&
        rectangle1.position.x <= rectangle2.position.x + rectangle2.width &&
        rectangle1.position.y <= rectangle2.position.y + rectangle2.height &&
        rectangle1.position.y + rectangle1.height >= rectangle2.position.y
      )
    }

    function checkForCharacterCollision({
      characters,
      player,
      characterOffset = { x: 0, y: 0 }
    }) {
      player.interactionAsset = null
      for (let i = 0; i < characters.length; i++) {
        const character = characters[i]

        if (
          rectangularCollision({
            rectangle1: player,
            rectangle2: {
              ...character,
              position: {
                x: character.position.x + characterOffset.x,
                y: character.position.y + characterOffset.y
              }
            }
          })
        ) {
          player.interactionAsset = character
          break
        }
      }
    }
  </script>

  <script>
    // classes.js
    class Sprite {
      constructor({
        position,
        velocity,
        image,
        frames = { max: 1, hold: 10 },
        sprites,
        animate = false,
        rotation = 0,
        scale = 1
      }) {
        this.position = position
        this.image = new Image()
        this.frames = { ...frames, val: 0, elapsed: 0 }
        this.image.onload = () => {
          this.width = (this.image.width / this.frames.max) * scale
          this.height = this.image.height * scale
        }
        this.image.src = image.src

        this.animate = animate
        this.sprites = sprites
        this.opacity = 1

        this.rotation = rotation
        this.scale = scale
      }

      draw() {
        c.save()
        c.translate(
          this.position.x + this.width / 2,
          this.position.y + this.height / 2
        )
        c.rotate(this.rotation)
        c.translate(
          -this.position.x - this.width / 2,
          -this.position.y - this.height / 2
        )
        c.globalAlpha = this.opacity

        const crop = {
          position: {
            x: this.frames.val * (this.width / this.scale),
            y: 0
          },
          width: this.image.width / this.frames.max,
          height: this.image.height
        }

        const image = {
          position: {
            x: this.position.x,
            y: this.position.y
          },
          width: this.image.width / this.frames.max,
          height: this.image.height
        }

        c.drawImage(
          this.image,
          crop.position.x,
          crop.position.y,
          crop.width,
          crop.height,
          image.position.x,
          image.position.y,
          image.width * this.scale,
          image.height * this.scale
        )

        c.restore()

        if (!this.animate) return

        if (this.frames.max > 1) {
          this.frames.elapsed++
        }

        if (this.frames.elapsed % this.frames.hold === 0) {
          if (this.frames.val < this.frames.max - 1) this.frames.val++
          else this.frames.val = 0
        }
      }
    }

    class Monster extends Sprite {
      constructor({
        position,
        velocity,
        image,
        frames = { max: 1, hold: 10 },
        sprites,
        animate = false,
        rotation = 0,
        isEnemy = false,
        name,
        attacks
      }) {
        super({
          position,
          velocity,
          image,
          frames,
          sprites,
          animate,
          rotation
        })
        this.health = 100
        this.isEnemy = isEnemy
        this.name = name
        this.attacks = attacks
      }

      faint() {
        document.querySelector('#dialogueBox').innerHTML = this.name + ' fainted!'
        gsap.to(this.position, {
          y: this.position.y + 20
        })
        gsap.to(this, {
          opacity: 0
        })
        audio.battle.stop()
        audio.victory.play()
      }

      attack({ attack, recipient, renderedSprites }) {
        document.querySelector('#dialogueBox').style.display = 'block'
        document.querySelector('#dialogueBox').innerHTML =
          this.name + ' used ' + attack.name

        let healthBar = '#enemyHealthBar'
        if (this.isEnemy) healthBar = '#playerHealthBar'

        let rotation = 1
        if (this.isEnemy) rotation = -2.2

        recipient.health -= attack.damage

        switch (attack.name) {
          case 'Fireball':
            audio.initFireball.play()
            const fireballImage = new Image()
            fireballImage.src = './img/fireball.png' // Replace
            const fireball = new Sprite({
              position: {
                x: this.position.x,
                y: this.position.y
              },
              image: fireballImage,
              frames: {
                max: 4,
                hold: 10
              },
              animate: true,
              rotation
            })
            renderedSprites.splice(1, 0, fireball)

            gsap.to(fireball.position, {
              x: recipient.position.x,
              y: recipient.position.y,
              onComplete: () => {
                audio.fireballHit.play()
                gsap.to(healthBar, {
                  width: recipient.health + '%'
                })

                gsap.to(recipient.position, {
                  x: recipient.position.x + 10,
                  yoyo: true,
                  repeat: 5,
                  duration: 0.08
                })

                gsap.to(recipient, {
                  opacity: 0,
                  repeat: 5,
                  yoyo: true,
                  duration: 0.08
                })
                renderedSprites.splice(1, 1)
              }
            })

            break
          case 'Tackle':
            const tl = gsap.timeline()

            let movementDistance = 20
            if (this.isEnemy) movementDistance = -20

            tl.to(this.position, {
              x: this.position.x - movementDistance
            })
              .to(this.position, {
                x: this.position.x + movementDistance * 2,
                duration: 0.1,
                onComplete: () => {
                  audio.tackleHit.play()
                  gsap.to(healthBar, {
                    width: recipient.health + '%'
                  })

                  gsap.to(recipient.position, {
                    x: recipient.position.x + 10,
                    yoyo: true,
                    repeat: 5,
                    duration: 0.08
                  })

                  gsap.to(recipient, {
                    opacity: 0,
                    repeat: 5,
                    yoyo: true,
                    duration: 0.08
                  })
                }
              })
              .to(this.position, {
                x: this.position.x
              })
            break
        }
      }
    }

    class Boundary {
      static width = 48
      static height = 48
      constructor({ position }) {
        this.position = position
        this.width = 48
        this.height = 48
      }

      draw() {
        c.fillStyle = 'rgba(255, 0, 0, 0)'
        c.fillRect(this.position.x, this.position.y, this.width, this.height)
      }
    }

    class Character extends Sprite {
      constructor({
        position,
        velocity,
        image,
        frames = { max: 1, hold: 10 },
        sprites,
        animate = false,
        rotation = 0,
        scale = 1,
        dialogue = ['']
      }) {
        super({
          position,
          velocity,
          image,
          frames,
          sprites,
          animate,
          rotation,
          scale
        })

        this.dialogue = dialogue
        this.dialogueIndex = 0
      }
    }
  </script>

  <script>
    // index.js modified
    const canvas = document.querySelector('canvas')
    const c = canvas.getContext('2d')

    canvas.width = 1024
    canvas.height = 576

    const collisionsMap = []
    for (let i = 0; i < collisions.length; i += 70) { // Adjust 70 to your map width
      collisionsMap.push(collisions.slice(i, 70 + i))
    }

    const battleZonesMap = []
    for (let i = 0; i < battleZonesData.length; i += 70) {
      battleZonesMap.push(battleZonesData.slice(i, 70 + i))
    }

    const charactersMap = []
    for (let i = 0; i < charactersMapData.length; i += 70) {
      charactersMap.push(charactersMapData.slice(i, 70 + i))
    }

    const boundaries = []
    const offset = {
      x: -735,
      y: -650
    } // Adjust offset for spawn

    collisionsMap.forEach((row, i) => {
      row.forEach((symbol, j) => {
        if (symbol === 1025)
          boundaries.push(
            new Boundary({
              position: {
                x: j * Boundary.width + offset.x,
                y: i * Boundary.height + offset.y
              }
            })
          )
      })
    })

    const battleZones = []

    battleZonesMap.forEach((row, i) => {
      row.forEach((symbol, j) => {
        if (symbol === 1025)
          battleZones.push(
            new Boundary({
              position: {
                x: j * Boundary.width + offset.x,
                y: i * Boundary.height + offset.y
              }
            })
          )
      })
    })

    const characters = []
    const professorImg = new Image()
    professorImg.src = 'https://example.com/path/to/professor.png' // Placeholder for professor

    const villagerImg = new Image()
    villagerImg.src = './img/villager/Idle.png' // Replace

    // Add characters including professor

    charactersMap.forEach((row, i) => {
      row.forEach((symbol, j) => {
        if (symbol === 1026) { // Villager
          characters.push(
            new Character({
              position: {
                x: j * Boundary.width + offset.x,
                y: i * Boundary.height + offset.y
              },
              image: villagerImg,
              frames: {
                max: 4,
                hold: 60
              },
              scale: 3,
              animate: true,
              dialogue: ['...']
            })
          )
        } // Add more for professor etc.
        if (symbol !== 0) {
          boundaries.push(
            new Boundary({
              position: {
                x: j * Boundary.width + offset.x,
                y: i * Boundary.height + offset.y
              }
            })
          )
        }
      })
    })

    const image = new Image()
    image.src = 'https://example.com/path/to/house_interior.png' // Placeholder for uploaded interior

    const foregroundImage = new Image()
    foregroundImage.src = './img/foregroundObjects.png' // Replace if needed

    const playerDownImage = new Image()
    playerDownImage.src = 'https://www.clipartmax.com/png/middle/193-1937664_photo-pokemon-trainer-red-sprite.png' // Use the spritesheet, adjust frames

    const playerUpImage = new Image()
    playerUpImage.src = 'https://www.clipartmax.com/png/middle/193-1937664_photo-pokemon-trainer-red-sprite.png'

    const playerLeftImage = new Image()
    playerLeftImage.src = 'https://www.clipartmax.com/png/middle/193-1937664_photo-pokemon-trainer-red-sprite.png'

    const playerRightImage = new Image()
    playerRightImage.src = 'https://www.clipartmax.com/png/middle/193-1937664_photo-pokemon-trainer-red-sprite.png'

    const player = new Sprite({
      position: {
        x: canvas.width / 2 - 192 / 4 / 2,
        y: canvas.height / 2 - 68 / 2
      },
      image: playerDownImage,
      frames: {
        max: 4, // Adjust for your spritesheet
        hold: 10
      },
      sprites: {
        up: playerUpImage,
        left: playerLeftImage,
        right: playerRightImage,
        down: playerDownImage
      }
    })

    const background = new Sprite({
      position: {
        x: offset.x,
        y: offset.y
      },
      image: image
    })

    const foreground = new Sprite({
      position: {
        x: offset.x,
        y: offset.y
      },
      image: foregroundImage
    })

    const keys = {
      w: {
        pressed: false
      },
      a: {
        pressed: false
      },
      s: {
        pressed: false
      },
      d: {
        pressed: false
      }
    }

    const movables = [
      background,
      ...boundaries,
      foreground,
      ...battleZones,
      ...characters
    ]
    const renderables = [
      background,
      ...boundaries,
      ...battleZones,
      ...characters,
      player,
      foreground
    ]

    const battle = {
      initiated: false
    }

    function animate() {
      const animationId = window.requestAnimationFrame(animate)
      renderables.forEach((renderable) => {
        renderable.draw()
      })

      let moving = true
      player.animate = false

      if (battle.initiated) return

      if (keys.w.pressed || keys.a.pressed || keys.s.pressed || keys.d.pressed) {
        for (let i = 0; i < battleZones.length; i++) {
          const battleZone = battleZones[i]
          const overlappingArea =
            (Math.min(
              player.position.x + player.width,
              battleZone.position.x + battleZone.width
            ) -
              Math.max(player.position.x, battleZone.position.x)) *
            (Math.min(
              player.position.y + player.height,
              battleZone.position.y + battleZone.height
            ) -
              Math.max(player.position.y, battleZone.position.y))
          if (
            rectangularCollision({
              rectangle1: player,
              rectangle2: battleZone
            }) &&
            overlappingArea > (player.width * player.height) / 2 &&
            Math.random() < 0.01
          ) {
            window.cancelAnimationFrame(animationId)

            audio.Map.stop()
            audio.initBattle.play()
            audio.battle.play()

            battle.initiated = true
            gsap.to('#overlappingDiv', {
              opacity: 1,
              repeat: 3,
              yoyo: true,
              duration: 0.4,
              onComplete() {
                gsap.to('#overlappingDiv', {
                  opacity: 1,
                  duration: 0.4,
                  onComplete() {
                    initBattle()
                    animateBattle()
                    gsap.to('#overlappingDiv', {
                      opacity: 0,
                      duration: 0.4
                    })
                  }
                })
              }
            })
            break
          }
        }
      }

      if (keys.w.pressed && lastKey === 'w') {
        player.animate = true
        player.image = player.sprites.up

        checkForCharacterCollision({
          characters,
          player,
          characterOffset: { x: 0, y: 3 }
        })

        for (let i = 0; i < boundaries.length; i++) {
          const boundary = boundaries[i]
          if (
            rectangularCollision({
              rectangle1: player,
              rectangle2: {
                ...boundary,
                position: {
                  x: boundary.position.x,
                  y: boundary.position.y + 3
                }
              }
            })
          ) {
            moving = false
            break
          }
        }

        if (moving)
          movables.forEach((movable) => {
            movable.position.y += 3
          })
      } else if (keys.a.pressed && lastKey === 'a') {
        player.animate = true
        player.image = player.sprites.left

        checkForCharacterCollision({
          characters,
          player,
          characterOffset: { x: 3, y: 0 }
        })

        for (let i = 0; i < boundaries.length; i++) {
          const boundary = boundaries[i]
          if (
            rectangularCollision({
              rectangle1: player,
              rectangle2: {
                ...boundary,
                position: {
                  x: boundary.position.x + 3,
                  y: boundary.position.y
                }
              }
            })
          ) {
            moving = false
            break
          }
        }

        if (moving)
          movables.forEach((movable) => {
            movable.position.x += 3
          })
      } else if (keys.s.pressed && lastKey === 's') {
        player.animate = true
        player.image = player.sprites.down

        checkForCharacterCollision({
          characters,
          player,
          characterOffset: { x: 0, y: -3 }
        })

        for (let i = 0; i < boundaries.length; i++) {
          const boundary = boundaries[i]
          if (
            rectangularCollision({
              rectangle1: player,
              rectangle2: {
                ...boundary,
                position: {
                  x: boundary.position.x,
                  y: boundary.position.y - 3
                }
              }
            })
          ) {
            moving = false
            break
          }
        }

        if (moving)
          movables.forEach((movable) => {
            movable.position.y -= 3
          })
      } else if (keys.d.pressed && lastKey === 'd') {
        player.animate = true
        player.image = player.sprites.right

        checkForCharacterCollision({
          characters,
          player,
          characterOffset: { x: -3, y: 0 }
        })

        for (let i = 0; i < boundaries.length; i++) {
          const boundary = boundaries[i]
          if (
            rectangularCollision({
              rectangle1: player,
              rectangle2: {
                ...boundary,
                position: {
                  x: boundary.position.x - 3,
                  y: boundary.position.y
                }
              }
            })
          ) {
            moving = false
            break
          }
        }

        if (moving)
          movables.forEach((movable) => {
            movable.position.x -= 3
          })
      }
    }

    let lastKey = ''
    window.addEventListener('keydown', (e) => {
      if (player.isInteracting) {
        switch (e.key) {
          case ' ':
            player.interactionAsset.dialogueIndex++

            const { dialogueIndex, dialogue } = player.interactionAsset
            if (dialogueIndex <= dialogue.length - 1) {
              document.querySelector('#characterDialogueBox').innerHTML =
                player.interactionAsset.dialogue[dialogueIndex]
              return
            }

            player.isInteracting = false
            player.interactionAsset.dialogueIndex = 0
            document.querySelector('#characterDialogueBox').style.display = 'none'

            break
        }
        return
      }

      switch (e.key) {
        case ' ':
          if (!player.interactionAsset) return

          const firstMessage = player.interactionAsset.dialogue[0]
          document.querySelector('#characterDialogueBox').innerHTML = firstMessage
          document.querySelector('#characterDialogueBox').style.display = 'flex'
          player.isInteracting = true
          break
        case 'w':
          keys.w.pressed = true
          lastKey = 'w'
          break
        case 'a':
          keys.a.pressed = true
          lastKey = 'a'
          break
        case 's':
          keys.s.pressed = true
          lastKey = 's'
          break
        case 'd':
          keys.d.pressed = true
          lastKey = 'd'
          break
      }
    })

    window.addEventListener('keyup', (e) => {
      switch (e.key) {
        case 'w':
          keys.w.pressed = false
          break
        case 'a':
          keys.a.pressed = false
          break
        case 's':
          keys.s.pressed = false
          break
        case 'd':
          keys.d.pressed = false
          break
      }
    })

    // Intro logic
    let playerName = '';
    let starterPokemon = null;

    const dialogue = [
      'Hello there! Welcome to the world of Pokémon! My name is Kyan!',
      'People call me the Pokémon Prof! This world is inhabited by creatures called Pokémon!',
      'For some people, Pokémon are pets. Others use them for fights. Myself… I study Pokémon as a profession.',
      'First, what is your name?'
      // After name, 'Your very own Pokémon legend is about to unfold!… A world of dreams and adventures with Pokémon awaits! Let\'s go!'
    ];

    let currentDialogueIndex = 0;

    const profDialogueBox = document.querySelector('#profDialogueBox');

    function showDialogue() {
      if (currentDialogueIndex < dialogue.length - 1) {
        profDialogueBox.innerHTML = dialogue[currentDialogueIndex].replace('...', '<br>Click to continue');
      } else {
        profDialogueBox.innerHTML = dialogue[currentDialogueIndex];
        document.querySelector('#nameInput').style.display = 'block';
      }
    }

    document.querySelector('#introScreen').addEventListener('click', () => {
      document.querySelector('#introScreen').style.display = 'none';
      document.querySelector('#professorScreen').style.display = 'flex';
      showDialogue();
    });

    document.querySelector('#professorScreen').addEventListener('click', (e) => {
      if (document.querySelector('#nameInput').style.display === 'block') return;
      if (document.querySelector('#starterChoice').style.display === 'flex') return;

      currentDialogueIndex++;
      if (currentDialogueIndex < dialogue.length) {
        showDialogue();
      } else {
        profDialogueBox.innerHTML = 'Hello ' + playerName + ' this is the beginning of your legendary adventure in the Pokémon World. Before you start as a trainer you will need to choose one of these following Pokémon';
        document.querySelector('#starterChoice').style.display = 'flex';
      }
    });

    document.querySelector('#nameInput').addEventListener('input', (e) => {
      playerName = e.target.value;
    });

    document.querySelector('#nameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && playerName) {
        document.querySelector('#nameInput').style.display = 'none';
        profDialogueBox.innerHTML = 'Your very own Pokémon legend is about to unfold!… A world of dreams and adventures with Pokémon awaits! Let\'s go!';
        currentDialogueIndex = dialogue.length; // To trigger next click to starter
      }
    });

    document.querySelectorAll('.starter').forEach(starter => {
      starter.addEventListener('click', (e) => {
        starterPokemon = e.target.dataset.starter;
        document.querySelector('#starterChoice').style.display = 'none';
        document.querySelector('#startButton').style.display = 'block';
      });
    });

    document.querySelector('#startButton').addEventListener('click', () => {
      document.querySelector('#professorScreen').style.display = 'none';
      // Set player starter
      // For example, monsters.Player = monsters[starterPokemon];
      // Start the game
      animate();
      audio.Map.play();
    });

    // Add door logic in movement, if player at door position, change background to outside, reset offset etc.

    // For mobile joystick, add touch events
    // Simple buttons
    // Add divs for up, down, left, right in HTML and style them, then add touchstart/touchend to press keys.

    // Example:
    // <div id="joystick-up" style="position: absolute; bottom: 200px; left: 50px; width: 50px; height: 50px; background: gray;"></div>
    // Then
    // document.querySelector('#joystick-up').addEventListener('touchstart', () => { keys.w.pressed = true; lastKey = 'w'; });
    // document.querySelector('#joystick-up').addEventListener('touchend', () => { keys.w.pressed = false; });
    // Similarly for others.

    // To prevent going through walls, the code already has collision.

    // For small POV, set canvas.width and height smaller, say 320x240, and scale.

    // For full game, add more Pokémon, gyms etc. This is the base.

    // Note: Replace all placeholders with your assets. For uploaded images, convert to base64 or host on GitHub.
    // For example, for professor, use data:base64 from your image.
    // To add more, expand the monsters, add catching in battles, etc.
  </script>

  <script>
    // battleScene.js
    const battleBackgroundImage = new Image()
    battleBackgroundImage.src = './img/battleBackground.png' // Replace
    const battleBackground = new Sprite({
      position: {
        x: 0,
        y: 0
      },
      image: battleBackgroundImage
    })

    let enemy
    let playerMon
    let renderedSprites
    let battleAnimationId
    let queue

    function initBattle() {
      document.querySelector('#userInterface').style.display = 'block'
      document.querySelector('#dialogueBox').style.display = 'none'
      document.querySelector('#enemyHealthBar').style.width = '100%'
      document.querySelector('#playerHealthBar').style.width = '100%'
      document.querySelector('#attacksBox').replaceChildren()

      // Random enemy for now
      enemy = new Monster(monsters.Draggle) // Change to random

      playerMon = new Monster(monsters[starterPokemon] || monsters.Emby) // Use chosen starter

      document.querySelector('#enemyName').innerHTML = enemy.name
      document.querySelector('#playerName').innerHTML = playerMon.name

      renderedSprites = [enemy, playerMon]
      queue = []

      playerMon.attacks.forEach((attack) => {
        const button = document.createElement('button')
        button.innerHTML = attack.name
        document.querySelector('#attacksBox').append(button)
      })

      document.querySelectorAll('button').forEach((button) => {
        button.addEventListener('click', (e) => {
          const selectedAttack = attacks[e.currentTarget.innerHTML]
          playerMon.attack({
            attack: selectedAttack,
            recipient: enemy,
            renderedSprites
          })

          if (enemy.health <= 0) {
            queue.push(() => {
              enemy.faint()
            })
            queue.push(() => {
              gsap.to('#overlappingDiv', {
                opacity: 1,
                onComplete: () => {
                  cancelAnimationFrame(battleAnimationId)
                  animate()
                  document.querySelector('#userInterface').style.display = 'none'

                  gsap.to('#overlappingDiv', {
                    opacity: 0
                  })

                  battle.initiated = false
                  audio.Map.play()
                }
              })
            })
          }

          const randomAttack = enemy.attacks[Math.floor(Math.random() * enemy.attacks.length)]

          queue.push(() => {
            enemy.attack({
              attack: randomAttack,
              recipient: playerMon,
              renderedSprites
            })

            if (playerMon.health <= 0) {
              queue.push(() => {
                playerMon.faint()
              })

              queue.push(() => {
                gsap.to('#overlappingDiv', {
                  opacity: 1,
                  onComplete: () => {
                    cancelAnimationFrame(battleAnimationId)
                    animate()
                    document.querySelector('#userInterface').style.display = 'none'

                    gsap.to('#overlappingDiv', {
                      opacity: 0
                    })

                    battle.initiated = false
                    audio.Map.play()
                  }
                })
              })
            }
          })
        })

        button.addEventListener('mouseenter', (e) => {
          const selectedAttack = attacks[e.currentTarget.innerHTML]
          document.querySelector('#attackType').innerHTML = selectedAttack.type
          document.querySelector('#attackType').style.color = selectedAttack.color
        })
      })
    }

    function animateBattle() {
      battleAnimationId = window.requestAnimationFrame(animateBattle)
      battleBackground.draw()

      renderedSprites.forEach((sprite) => {
        sprite.draw()
      })
    }

    document.querySelector('#dialogueBox').addEventListener('click', (e) => {
      if (queue.length > 0) {
        queue[0]()
        queue.shift()
      } else e.currentTarget.style.display = 'none'
    })
  </script>
</body>
</html>
