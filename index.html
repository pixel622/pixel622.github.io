<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Game...</div>
    <div id="ui">
        <div>WASD: Move | Space: Jump | Mouse: Look around</div>
        <div id="score">Score: 0</div>
        <div id="position">Position: (0, 0, 0)</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // ==================== SCENE SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

        // ==================== CAMERA ====================
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        // ==================== RENDERER ====================
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // ==================== CONTROLS ====================
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.target.set(0, 2, 0);

        // ==================== LIGHTING ====================
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // Directional light (sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.bias = -0.001;
        scene.add(directionalLight);

        // Hemisphere light for sky/ground color
        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x808080, 0.4);
        scene.add(hemisphereLight);

        // ==================== CAPSULE GEOMETRY FIX ====================
        // Custom CapsuleGeometry implementation since it might not be available
        function createCapsuleGeometry(radius = 0.35, height = 1.4, radialSegments = 8, heightSegments = 16) {
            const geometry = new THREE.BufferGeometry();
            
            const vertices = [];
            const indices = [];
            const normals = [];
            const uvs = [];
            
            // Helper function to add a vertex with normal and UV
            function addVertex(x, y, z, u, v) {
                vertices.push(x, y, z);
                const length = Math.sqrt(x * x + y * y + z * z);
                normals.push(x / length, y / length, z / length);
                uvs.push(u, v);
            }
            
            // Create top hemisphere vertices
            const topOffset = height / 2;
            for (let y = 0; y <= heightSegments / 2; y++) {
                const v = y / (heightSegments / 2);
                const theta = v * Math.PI / 2;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let x = 0; x <= radialSegments; x++) {
                    const u = x / radialSegments;
                    const phi = u * Math.PI * 2;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const px = radius * cosPhi * sinTheta;
                    const py = radius * cosTheta + topOffset;
                    const pz = radius * sinPhi * sinTheta;
                    
                    addVertex(px, py, pz, u, 1 - v * 0.5);
                }
            }
            
            // Create bottom hemisphere vertices
            const bottomOffset = -height / 2;
            const vertexOffset = (Math.floor(heightSegments / 2) + 1) * (radialSegments + 1);
            for (let y = 0; y <= heightSegments / 2; y++) {
                const v = y / (heightSegments / 2);
                const theta = Math.PI / 2 + v * Math.PI / 2;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let x = 0; x <= radialSegments; x++) {
                    const u = x / radialSegments;
                    const phi = u * Math.PI * 2;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const px = radius * cosPhi * sinTheta;
                    const py = radius * cosTheta + bottomOffset;
                    const pz = radius * sinPhi * sinTheta;
                    
                    addVertex(px, py, pz, u, 0.5 - v * 0.5);
                }
            }
            
            // Create indices for top hemisphere
            for (let y = 0; y < heightSegments / 2; y++) {
                for (let x = 0; x < radialSegments; x++) {
                    const a = y * (radialSegments + 1) + x;
                    const b = a + radialSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            // Create indices for bottom hemisphere
            for (let y = 0; y < heightSegments / 2; y++) {
                for (let x = 0; x < radialSegments; x++) {
                    const a = vertexOffset + y * (radialSegments + 1) + x;
                    const b = a + radialSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, c, b);
                    indices.push(b, c, d);
                }
            }
            
            // Create cylinder vertices (middle section if needed)
            // Note: For a proper capsule, we also need the cylindrical middle
            // This is a simplified version that works for the player model
            
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            
            return geometry;
        }

        // ==================== PLAYER CLASS ====================
        class Player {
            constructor() {
                // Create capsule geometry using our custom function
                this.geometry = createCapsuleGeometry(0.35, 1.4, 8, 16);
                this.material = new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    roughness: 0.7,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.1
                });
                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.name = 'Player';
                
                // Physics properties
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.direction = new THREE.Vector3(0, 0, 0);
                this.speed = 5.0;
                this.jumpForce = 8.0;
                this.isOnGround = false;
                this.gravity = 9.8;
                this.friction = 0.9;
                this.airResistance = 0.98;
                
                // Player state
                this.health = 100;
                this.score = 0;
                
                // Add player to scene
                scene.add(this.mesh);
                
                // Player collision box (simplified sphere)
                this.boundingSphere = new THREE.Sphere(this.mesh.position, 0.5);
            }
            
            update(deltaTime) {
                // Apply gravity if not on ground
                if (!this.isOnGround) {
                    this.velocity.y -= this.gravity * deltaTime;
                }
                
                // Apply friction and air resistance
                if (this.isOnGround) {
                    this.velocity.x *= this.friction;
                    this.velocity.z *= this.friction;
                } else {
                    this.velocity.x *= this.airResistance;
                    this.velocity.z *= this.airResistance;
                }
                
                // Update position
                this.mesh.position.x += this.velocity.x * deltaTime;
                this.mesh.position.y += this.velocity.y * deltaTime;
                this.mesh.position.z += this.velocity.z * deltaTime;
                
                // Update bounding sphere position
                this.boundingSphere.center.copy(this.mesh.position);
                
                // Ground collision (simple ground at y=0)
                if (this.mesh.position.y < 0) {
                    this.mesh.position.y = 0;
                    this.velocity.y = 0;
                    this.isOnGround = true;
                }
                
                // Boundary constraints
                const boundary = 45;
                this.mesh.position.x = Math.max(-boundary, Math.min(boundary, this.mesh.position.x));
                this.mesh.position.z = Math.max(-boundary, Math.min(boundary, this.mesh.position.z));
                
                // Rotate player based on movement direction
                if (this.velocity.x !== 0 || this.velocity.z !== 0) {
                    const angle = Math.atan2(this.velocity.x, this.velocity.z);
                    this.mesh.rotation.y = angle;
                }
            }
            
            move(forward, right) {
                this.direction.set(right, 0, -forward).normalize();
                
                // Apply movement to velocity
                if (this.isOnGround) {
                    this.velocity.x = this.direction.x * this.speed;
                    this.velocity.z = this.direction.z * this.speed;
                } else {
                    // Allow some air control
                    this.velocity.x += this.direction.x * this.speed * 0.1;
                    this.velocity.z += this.direction.z * this.speed * 0.1;
                    
                    // Limit horizontal speed in air
                    const horizontalSpeed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);
                    const maxAirSpeed = this.speed * 0.8;
                    if (horizontalSpeed > maxAirSpeed) {
                        const scale = maxAirSpeed / horizontalSpeed;
                        this.velocity.x *= scale;
                        this.velocity.z *= scale;
                    }
                }
            }
            
            jump() {
                if (this.isOnGround) {
                    this.velocity.y = this.jumpForce;
                    this.isOnGround = false;
                    return true;
                }
                return false;
            }
            
            stop() {
                if (this.isOnGround) {
                    this.velocity.x = 0;
                    this.velocity.z = 0;
                }
            }
            
            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                return this.health > 0;
            }
            
            addScore(points) {
                this.score += points;
                return this.score;
            }
            
            getPosition() {
                return this.mesh.position.clone();
            }
            
            reset() {
                this.mesh.position.set(0, 2, 0);
                this.velocity.set(0, 0, 0);
                this.health = 100;
                this.isOnGround = false;
            }
        }

        // ==================== GAME MANAGER ====================
        class Game {
            constructor() {
                this.player = new Player();
                this.keys = {};
                this.clock = new THREE.Clock();
                this.platforms = [];
                this.collectibles = [];
                this.obstacles = [];
                this.gameTime = 0;
                this.isPaused = false;
                this.gameOver = false;
                
                this.init();
                this.setupEventListeners();
                this.hideLoadingScreen();
                this.animate();
            }
            
            init() {
                // ==================== GROUND ====================
                const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x808080,
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                ground.name = 'Ground';
                scene.add(ground);
                
                // Add ground texture variation
                const groundColors = [0x808080, 0x707070, 0x909090];
                const groundVertices = groundGeometry.attributes.position;
                const groundColorsAttr = new Float32Array(groundVertices.count * 3);
                
                for (let i = 0; i < groundVertices.count; i++) {
                    const x = groundVertices.getX(i);
                    const z = groundVertices.getY(i);
                    const colorIndex = Math.floor((x + z) * 2) % groundColors.length;
                    const color = new THREE.Color(groundColors[colorIndex]);
                    
                    groundColorsAttr[i * 3] = color.r;
                    groundColorsAttr[i * 3 + 1] = color.g;
                    groundColorsAttr[i * 3 + 2] = color.b;
                }
                
                groundGeometry.setAttribute('color', new THREE.BufferAttribute(groundColorsAttr, 3));
                groundMaterial.vertexColors = true;
                
                // ==================== PLATFORMS ====================
                const platformGeometry = new THREE.BoxGeometry(5, 0.5, 5);
                const platformMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a90e2,
                    roughness: 0.6,
                    metalness: 0.3
                });
                
                // Create multiple platforms at different heights and positions
                const platformPositions = [
                    { x: -15, y: 3, z: -10 },
                    { x: 10, y: 5, z: -5 },
                    { x: -5, y: 7, z: 15 },
                    { x: 20, y: 4, z: 10 },
                    { x: -20, y: 6, z: 20 },
                    { x: 15, y: 8, z: -15 },
                    { x: -10, y: 10, z: -20 },
                    { x: 5, y: 12, z: 5 }
                ];
                
                for (let i = 0; i < platformPositions.length; i++) {
                    const pos = platformPositions[i];
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.position.set(pos.x, pos.y, pos.z);
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    platform.name = `Platform_${i}`;
                    
                    // Add subtle rotation for visual interest
                    platform.rotation.y = Math.random() * Math.PI;
                    
                    scene.add(platform);
                    this.platforms.push({
                        mesh: platform,
                        boundingBox: new THREE.Box3().setFromObject(platform)
                    });
                }
                
                // ==================== OBSTACLES ====================
                const obstacleGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
                const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff4444,
                    roughness: 0.5,
                    metalness: 0.5,
                    emissive: 0x440000,
                    emissiveIntensity: 0.2
                });
                
                // Create multiple obstacles
                for (let i = 0; i < 15; i++) {
                    const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                    obstacle.position.set(
                        (Math.random() - 0.5) * 80,
                        1,
                        (Math.random() - 0.5) * 80
                    );
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                    obstacle.name = `Obstacle_${i}`;
                    
                    // Add rotation animation
                    obstacle.userData.rotationSpeed = (Math.random() - 0.5) * 2;
                    
                    scene.add(obstacle);
                    this.obstacles.push({
                        mesh: obstacle,
                        boundingSphere: new THREE.Sphere(obstacle.position, 0.7)
                    });
                }
                
                // ==================== COLLECTIBLES ====================
                const collectibleGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const collectibleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffdd00,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5,
                    roughness: 0.3,
                    metalness: 0.8
                });
                
                // Create multiple collectibles
                for (let i = 0; i < 30; i++) {
                    const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
                    
                    // Place collectibles on platforms or near ground
                    let x, y, z;
                    if (i < 15) {
                        // On ground
                        x = (Math.random() - 0.5) * 90;
                        y = 0.5;
                        z = (Math.random() - 0.5) * 90;
                    } else {
                        // On platforms
                        const platformIndex = Math.floor(Math.random() * this.platforms.length);
                        const platform = this.platforms[platformIndex];
                        x = platform.mesh.position.x + (Math.random() - 0.5) * 3;
                        y = platform.mesh.position.y + 0.8;
                        z = platform.mesh.position.z + (Math.random() - 0.5) * 3;
                    }
                    
                    collectible.position.set(x, y, z);
                    collectible.castShadow = true;
                    collectible.name = `Collectible_${i}`;
                    
                    // Add floating animation
                    collectible.userData.floatSpeed = 0.5 + Math.random() * 1.0;
                    collectible.userData.floatHeight = 0.2 + Math.random() * 0.3;
                    collectible.userData.floatOffset = Math.random() * Math.PI * 2;
                    collectible.userData.rotationSpeed = (Math.random() - 0.5) * 3;
                    collectible.userData.collected = false;
                    
                    scene.add(collectible);
                    this.collectibles.push(collectible);
                }
                
                // ==================== SKYBOX ====================
                const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                const skyMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                scene.add(sky);
                
                // ==================== TREES/ENVIRONMENT ====================
                // Create some simple trees
                const treeTrunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
                const treeCrownGeometry = new THREE.SphereGeometry(1, 8, 8);
                const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
                const treeCrownMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 });
                
                for (let i = 0; i < 20; i++) {
                    const treeTrunk = new THREE.Mesh(treeTrunkGeometry, treeTrunkMaterial);
                    const treeCrown = new THREE.Mesh(treeCrownGeometry, treeCrownMaterial);
                    
                    treeTrunk.position.set(
                        (Math.random() - 0.5) * 80,
                        1,
                        (Math.random() - 0.5) * 80
                    );
                    treeCrown.position.copy(treeTrunk.position);
                    treeCrown.position.y += 1.8;
                    
                    treeTrunk.castShadow = true;
                    treeTrunk.receiveShadow = true;
                    treeCrown.castShadow = true;
                    treeCrown.receiveShadow = true;
                    
                    scene.add(treeTrunk);
                    scene.add(treeCrown);
                }
                
                console.log('Game initialized with:', this.platforms.length, 'platforms,', 
                          this.obstacles.length, 'obstacles,', 
                          this.collectibles.length, 'collectibles');
            }
            
            hideLoadingScreen() {
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
            }
            
            setupEventListeners() {
                // Keyboard input
                window.addEventListener('keydown', (event) => {
                    const key = event.key.toLowerCase();
                    this.keys[key] = true;
                    
                    // Prevent space bar from scrolling page
                    if (key === ' ') {
                        event.preventDefault();
                    }
                    
                    // Jump on space bar
                    if (key === ' ') {
                        this.player.jump();
                    }
                    
                    // Pause game on Escape
                    if (key === 'escape') {
                        this.isPaused = !this.isPaused;
                        console.log('Game', this.isPaused ? 'paused' : 'resumed');
                    }
                    
                    // Reset game on R
                    if (key === 'r') {
                        this.resetGame();
                    }
                });
                
                window.addEventListener('keyup', (event) => {
                    const key = event.key.toLowerCase();
                    this.keys[key] = false;
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Prevent right-click menu
                renderer.domElement.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
                
                // Mouse click for testing
                window.addEventListener('click', () => {
                    if (document.pointerLockElement === renderer.domElement) {
                        // Player clicked while pointer is locked
                    }
                });
            }
            
            handleInput() {
                if (this.isPaused || this.gameOver) return;
                
                let forward = 0;
                let right = 0;
                
                // Movement keys
                if (this.keys['w'] || this.keys['arrowup']) forward += 1;
                if (this.keys['s'] || this.keys['arrowdown']) forward -= 1;
                if (this.keys['a'] || this.keys['arrowleft']) right -= 1;
                if (this.keys['d'] || this.keys['arrowright']) right += 1;
                
                // Move player if any movement key is pressed
                if (forward !== 0 || right !== 0) {
                    this.player.move(forward, right);
                } else {
                    this.player.stop();
                }
            }
            
            checkCollisions() {
                const playerPos = this.player.getPosition();
                const playerSphere = this.player.boundingSphere;
                
                // ==================== PLATFORM COLLISIONS ====================
                for (const platform of this.platforms) {
                    const platformBox = platform.boundingBox;
                    
                    // Check if player is above platform and within its bounds
                    if (playerPos.y >= platform.mesh.position.y - 0.5 && 
                        playerPos.y <= platform.mesh.position.y + 1) {
                        
                        const platformCenter = new THREE.Vector3();
                        platformBox.getCenter(platformCenter);
                        
                        const distanceX = Math.abs(playerPos.x - platformCenter.x);
                        const distanceZ = Math.abs(playerPos.z - platformCenter.z);
                        
                        // Platform is 5x5 units
                        if (distanceX < 2.5 && distanceZ < 2.5) {
                            // Player is on platform
                            if (playerPos.y < platform.mesh.position.y + 0.5) {
                                playerPos.y = platform.mesh.position.y + 0.5;
                                this.player.mesh.position.y = playerPos.y;
                                this.player.velocity.y = 0;
                                this.player.isOnGround = true;
                            }
                        }
                    }
                }
                
                // ==================== OBSTACLE COLLISIONS ====================
                for (const obstacle of this.obstacles) {
                    const distance = playerPos.distanceTo(obstacle.mesh.position);
                    
                    if (distance < 1.2) { // Player radius + obstacle radius
                        // Player hit obstacle
                        this.player.takeDamage(10);
                        
                        // Knockback effect
                        const knockbackDir = playerPos.clone().sub(obstacle.mesh.position).normalize();
                        this.player.velocity.x = knockbackDir.x * 5;
                        this.player.velocity.z = knockbackDir.z * 5;
                        this.player.velocity.y = 3;
                        this.player.isOnGround = false;
                        
                        // Visual feedback
                        obstacle.mesh.material.emissiveIntensity = 1.0;
                        setTimeout(() => {
                            obstacle.mesh.material.emissiveIntensity = 0.2;
                        }, 200);
                        
                        console.log('Player hit obstacle! Health:', this.player.health);
                        break;
                    }
                }
                
                // ==================== COLLECTIBLE COLLECTIONS ====================
                for (let i = this.collectibles.length - 1; i >= 0; i--) {
                    const collectible = this.collectibles[i];
                    
                    if (collectible.userData.collected) continue;
                    
                    const distance = playerPos.distanceTo(collectible.position);
                    
                    if (distance < 0.8) { // Player radius + collectible radius
                        // Collect the item
                        collectible.userData.collected = true;
                        this.player.addScore(10);
                        
                        // Visual effect
                        collectible.material.emissiveIntensity = 2.0;
                        collectible.material.opacity = 0.5;
                        collectible.material.transparent = true;
                        
                        // Remove from scene after animation
                        setTimeout(() => {
                            scene.remove(collectible);
                            this.collectibles.splice(i, 1);
                        }, 300);
                        
                        console.log('Collected item! Score:', this.player.score);
                    }
                }
                
                // ==================== BOUNDARY CHECK ====================
                if (playerPos.y < -10) {
                    // Player fell off
                    this.player.takeDamage(20);
                    this.player.reset();
                    console.log('Player fell! Health:', this.player.health);
                }
                
                // ==================== GAME OVER CHECK ====================
                if (this.player.health <= 0 && !this.gameOver) {
                    this.gameOver = true;
                    console.log('GAME OVER! Final Score:', this.player.score);
                    alert(`Game Over! Your score: ${this.player.score}`);
                }
            }
            
            updateCollectibles(deltaTime) {
                // Animate collectibles (floating and rotating)
                for (const collectible of this.collectibles) {
                    if (collectible.userData.collected) continue;
                    
                    // Floating animation
                    const floatTime = this.gameTime * collectible.userData.floatSpeed + collectible.userData.floatOffset;
                    collectible.position.y += Math.sin(floatTime) * 0.005;
                    
                    // Rotation animation
                    collectible.rotation.y += collectible.userData.rotationSpeed * deltaTime;
                    collectible.rotation.x = Math.sin(floatTime) * 0.1;
                }
            }
            
            updateObstacles(deltaTime) {
                // Animate obstacles (rotating)
                for (const obstacle of this.obstacles) {
                    obstacle.mesh.rotation.y += obstacle.mesh.userData.rotationSpeed * deltaTime;
                }
            }
            
            updateUI() {
                const scoreElement = document.getElementById('score');
                const positionElement = document.getElementById('position');
                
                if (scoreElement) {
                    scoreElement.textContent = `Score: ${this.player.score} | Health: ${this.player.health}`;
                }
                
                if (positionElement) {
                    const pos = this.player.getPosition();
                    positionElement.textContent = `Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`;
                }
            }
            
            resetGame() {
                // Reset player
                this.player.reset();
                this.player.score = 0;
                this.player.health = 100;
                
                // Reset collectibles
                for (const collectible of this.collectibles) {
                    scene.remove(collectible);
                }
                this.collectibles = [];
                
                // Recreate collectibles
                const collectibleGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const collectibleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffdd00,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5,
                    roughness: 0.3,
                    metalness: 0.8
                });
                
                for (let i = 0; i < 30; i++) {
                    const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
                    
                    let x, y, z;
                    if (i < 15) {
                        x = (Math.random() - 0.5) * 90;
                        y = 0.5;
                        z = (Math.random() - 0.5) * 90;
                    } else {
                        const platformIndex = Math.floor(Math.random() * this.platforms.length);
                        const platform = this.platforms[platformIndex];
                        x = platform.mesh.position.x + (Math.random() - 0.5) * 3;
                        y = platform.mesh.position.y + 0.8;
                        z = platform.mesh.position.z + (Math.random() - 0.5) * 3;
                    }
                    
                    collectible.position.set(x, y, z);
                    collectible.castShadow = true;
                    collectible.name = `Collectible_${i}`;
                    
                    collectible.userData.floatSpeed = 0.5 + Math.random() * 1.0;
                    collectible.userData.floatHeight = 0.2 + Math.random() * 0.3;
                    collectible.userData.floatOffset = Math.random() * Math.PI * 2;
                    collectible.userData.rotationSpeed = (Math.random() - 0.5) * 3;
                    collectible.userData.collected = false;
                    
                    scene.add(collectible);
                    this.collectibles.push(collectible);
                }
                
                // Reset game state
                this.gameOver = false;
                this.isPaused = false;
                this.gameTime = 0;
                
                console.log('Game reset!');
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.isPaused) return;
                
                const deltaTime = Math.min(this.clock.getDelta(), 0.1);
                this.gameTime += deltaTime;
                
                // Handle input
                this.handleInput();
                
                // Update player
                this.player.update(deltaTime);
                
                // Update animations
                this.updateCollectibles(deltaTime);
                this.updateObstacles(deltaTime);
                
                // Check collisions
                this.checkCollisions();
                
                // Update UI
                this.updateUI();
                
                // Update controls
                controls.update();
                
                // Render scene
                renderer.render(scene, camera);
            }
        }

        // ==================== INITIALIZE GAME ====================
        // Wait for page to load completely
        window.addEventListener('load', () => {
            try {
                console.log('Initializing game...');
                
                // Create and start the game
                const game = new Game();
                
                // Make game globally accessible for debugging
                window.game = game;
                
                console.log('Game loaded successfully!');
                console.log('Controls: WASD to move, Space to jump, Escape to pause, R to reset');
                
            } catch (error) {
                console.error('Game initialization error:', error);
                
                // Show error message to user
                const errorMessage = document.createElement('div');
                errorMessage.style.position = 'absolute';
                errorMessage.style.top = '50%';
                errorMessage.style.left = '50%';
                errorMessage.style.transform = 'translate(-50%, -50%)';
                errorMessage.style.color = 'red';
                errorMessage.style.fontSize = '20px';
                errorMessage.style.backgroundColor = 'rgba(0,0,0,0.8)';
                errorMessage.style.padding = '20px';
                errorMessage.style.borderRadius = '10px';
                errorMessage.style.textAlign = 'center';
                errorMessage.innerHTML = `
                    <h2>Game Failed to Load</h2>
                    <p>${error.message}</p>
                    <p>Please check the browser console for details.</p>
                    <p>Try refreshing the page or check your internet connection.</p>
                `;
                document.body.appendChild(errorMessage);
                
                // Hide loading screen
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
            }
        });

        // ==================== ERROR HANDLING ====================
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            event.preventDefault();
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            event.preventDefault();
        });

    </script>
</body>
</html>
