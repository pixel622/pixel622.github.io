<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Correcting Text Editor - English/French</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 75px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(to right, #1a2980, #26d0ce);
            color: white;
            padding: 30px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 2.2rem;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .title-icon {
            font-size: 2.5rem;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        select, .btn {
            padding: 12px 24px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select {
            background: white;
            border: 2px solid rgba(255,255,255,0.3);
            color: #333;
            min-width: 200px;
        }

        select:focus {
            outline: none;
            border-color: #26d0ce;
        }

        .btn {
            background: linear-gradient(to right, #ff7e5f, #feb47b);
            color: white;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,126,95,0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 40px;
            min-height: 600px;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-title {
            color: #1a2980;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 10px;
            border-bottom: 3px solid #26d0ce;
        }

        .panel-title::before {
            content: "üìù";
            font-size: 1.5rem;
        }

        #correctedPanel .panel-title::before {
            content: "‚úÖ";
        }

        .text-container {
            flex: 1;
            border: 2px solid #e1e8ed;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            background: #f8fafc;
        }

        .text-area {
            width: 100%;
            height: 100%;
            min-height: 400px;
            padding: 25px;
            border: none;
            resize: none;
            font-size: 16px;
            line-height: 1.7;
            background: transparent;
            color: #333;
            font-family: 'Georgia', serif;
        }

        .text-area:focus {
            outline: none;
        }

        .error-highlight {
            background: rgba(255, 165, 0, 0.2);
            border-bottom: 2px solid #ff8c00;
            position: relative;
            cursor: help;
        }

        .error-highlight::after {
            content: "‚ö†Ô∏è";
            position: absolute;
            right: -25px;
            top: -10px;
            font-size: 12px;
        }

        .correction-badge {
            background: #4CAF50;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            position: absolute;
            right: 10px;
            top: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .correction-badge span {
            font-weight: bold;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(to right, #f8f9fa, #e9ecef);
            border-radius: 12px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #1a2980;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .correction-list {
            background: #f0fff4;
            border: 2px solid #81c784;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .correction-list h3 {
            color: #2e7d32;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .correction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 4px solid #81c784;
        }

        .correction-from {
            color: #d32f2f;
            text-decoration: line-through;
            font-weight: 500;
        }

        .correction-to {
            color: #2e7d32;
            font-weight: 600;
        }

        .correction-arrow {
            color: #666;
            margin: 0 10px;
        }

        footer {
            text-align: center;
            padding: 25px;
            background: #f8f9fa;
            color: #666;
            border-top: 1px solid #dee2e6;
        }

        .language-info {
            display: inline-block;
            padding: 8px 20px;
            background: #e3f2fd;
            color: #1976d2;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-top: 10px;
        }

        .loading-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            z-index: 10;
        }

        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #26d0ce;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .quality-meter {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .quality-fill {
            height: 100%;
            background: linear-gradient(to right, #ff5252, #ffeb3b, #4caf50);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 300px;
        }

        .copy-btn {
            background: linear-gradient(to right, #4CAF50, #45a049);
            margin-left: auto;
        }

        .auto-correct {
            background: linear-gradient(to right, #2196F3, #21CBF3);
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 10px;
        }

        .badge-success { background: #4CAF50; color: white; }
        .badge-warning { background: #FF9800; color: white; }
        .badge-error { background: #f44336; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><span class="title-icon">‚ú®</span> Auto-Correcting Text Editor</h1>
            <div class="controls">
                <select id="languageSelect">
                    <option value="en-US">üá∫üá∏ English (US)</option>
                    <option value="en-GB">üá¨üáß English (UK)</option>
                    <option value="fr-FR">üá´üá∑ French (France)</option>
                    <option value="fr-CA">üá®üá¶ French (Canada)</option>
                </select>
                <button id="autoCorrectBtn" class="btn auto-correct">
                    <span>‚ö° Auto-Correct All</span>
                </button>
                <button id="copyBtn" class="btn copy-btn">
                    <span>üìã Copy Corrected Text</span>
                </button>
            </div>
        </header>

        <div class="main-content">
            <!-- Original Text Panel -->
            <div class="panel">
                <div class="panel-title">
                    Original Text with Errors Highlighted
                    <span class="badge badge-error" id="errorCountBadge">0 errors</span>
                </div>
                <div class="text-container">
                    <div class="loading-overlay" id="loadingOriginal">
                        <div class="spinner"></div>
                    </div>
                    <div class="correction-badge">
                        <span id="originalErrorCount">0</span> errors marked
                    </div>
                    <div class="text-area" id="originalText" contenteditable="true" spellcheck="false">
Hello their,

I went to the store yesterday and buyed some apples. The apples was very good. Me and my friend we really enjoyed them. 

Example of common errors that peoples makes often:
- Your going to love this
- Its a beautiful day
- They're house is big
- We should of gone earlier
- I could care less

In French: Je suis all√© au supermarch√© et j'ai acheter des pommes. Les pommes √©taient tr√®s bon. Moi et mon ami nous avons vraiment appr√©ci√©.

This text contains multiple types of errors including spelling, grammar, punctuation, and style issues that will be automatically corrected.
                    </div>
                </div>
            </div>

            <!-- Corrected Text Panel -->
            <div class="panel">
                <div class="panel-title">
                    Auto-Corrected Text
                    <span class="badge badge-success" id="correctionCountBadge">0 corrections</span>
                </div>
                <div class="text-container">
                    <div class="loading-overlay" id="loadingCorrected">
                        <div class="spinner"></div>
                    </div>
                    <div class="correction-badge">
                        <span id="correctionCount">0</span> corrections applied
                    </div>
                    <div class="text-area" id="correctedText" contenteditable="false">
                        <!-- Corrected text will appear here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-number" id="wordCount">0</div>
                <div class="stat-label">Words</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="charCount">0</div>
                <div class="stat-label">Characters</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="errorCount">0</div>
                <div class="stat-label">Errors Found</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="correctionApplied">0</div>
                <div class="stat-label">Corrections</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="qualityScore">100%</div>
                <div class="stat-label">Quality Score</div>
            </div>
        </div>

        <!-- Corrections List -->
        <div class="correction-list" id="correctionsList">
            <h3>üìã Applied Corrections</h3>
            <div id="correctionsContainer">
                <!-- Corrections will be listed here -->
            </div>
        </div>

        <footer>
            <p>‚úÖ <strong>All mistakes are automatically corrected</strong> - Spelling, grammar, punctuation, and style</p>
            <div class="language-info" id="currentLanguage">Currently checking: English (US)</div>
            <p style="margin-top: 15px; font-size: 0.9rem; color: #888;">
                Orange underlines indicate errors. Hover over them for details. Corrected text updates in real-time.
            </p>
        </footer>
    </div>

    <!-- Tooltip Element -->
    <div class="tooltip" id="errorTooltip"></div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const originalText = document.getElementById('originalText');
            const correctedText = document.getElementById('correctedText');
            const languageSelect = document.getElementById('languageSelect');
            const autoCorrectBtn = document.getElementById('autoCorrectBtn');
            const copyBtn = document.getElementById('copyBtn');
            const errorTooltip = document.getElementById('errorTooltip');
            
            // Stats elements
            const wordCount = document.getElementById('wordCount');
            const charCount = document.getElementById('charCount');
            const errorCount = document.getElementById('errorCount');
            const correctionApplied = document.getElementById('correctionApplied');
            const qualityScore = document.getElementById('qualityScore');
            const errorCountBadge = document.getElementById('errorCountBadge');
            const correctionCountBadge = document.getElementById('correctionCountBadge');
            const originalErrorCount = document.getElementById('originalErrorCount');
            const correctionCount = document.getElementById('correctionCount');
            const correctionsContainer = document.getElementById('correctionsContainer');
            const currentLanguage = document.getElementById('currentLanguage');

            // Comprehensive correction rules database
            const correctionRules = {
                'en': {
                    spelling: {
                        'their': 'there',
                        'theyre': 'they\'re',
                        'your': 'you\'re',
                        'youre': 'you\'re',
                        'its': 'it\'s',
                        'whos': 'who\'s',
                        'wont': 'won\'t',
                        'cant': 'can\'t',
                        'dont': 'don\'t',
                        'doesnt': 'doesn\'t',
                        'isnt': 'isn\'t',
                        'wasnt': 'wasn\'t',
                        'shouldnt': 'shouldn\'t',
                        'couldnt': 'couldn\'t',
                        'wouldnt': 'wouldn\'t',
                        'havent': 'haven\'t',
                        'hasnt': 'hasn\'t',
                        'hadnt': 'hadn\'t',
                        'exemple': 'example',
                        'peoples': 'people',
                        'buyed': 'bought',
                        'goed': 'went',
                        'eated': 'ate',
                        'runned': 'ran',
                        'breaked': 'broke',
                        'catched': 'caught',
                        'teached': 'taught',
                        'writed': 'wrote',
                        'speaked': 'spoke',
                        'drinked': 'drank',
                        'swimmed': 'swam',
                        'breath': 'breathe',
                        'loose': 'lose',
                        'definately': 'definitely',
                        'seperate': 'separate',
                        'occured': 'occurred',
                        'recieve': 'receive',
                        'wierd': 'weird',
                        'acheive': 'achieve',
                        'grammer': 'grammar',
                        'occassion': 'occasion',
                        'comming': 'coming',
                        'begining': 'beginning',
                        'enviornment': 'environment',
                        'goverment': 'government',
                        'arguement': 'argument',
                        'judgement': 'judgment'
                    },
                    grammar: {
                        'was': (word, context) => context.nextWord && /^(they|we|you|people|apples|dogs|cats)$/i.test(context.nextWord) ? 'were' : word,
                        'is': (word, context) => context.nextWord && /^(they|we|you|people|apples|dogs|cats)$/i.test(context.nextWord) ? 'are' : word,
                        'has': (word, context) => context.nextWord && /^(they|we|you|people)$/i.test(context.nextWord) ? 'have' : word,
                        'does': (word, context) => context.nextWord && /^(they|we|you|people)$/i.test(context.nextWord) ? 'do' : word,
                        'me and': 'and I',
                        'and me': 'and I',
                        'i and': 'and I'
                    },
                    expressions: {
                        'could care less': 'couldn\'t care less',
                        'should of': 'should have',
                        'would of': 'would have',
                        'could of': 'could have',
                        'must of': 'must have',
                        'for all intensive purposes': 'for all intents and purposes',
                        'one in the same': 'one and the same',
                        'nip it in the butt': 'nip it in the bud',
                        'case and point': 'case in point',
                        'first come, first serve': 'first come, first served',
                        'on accident': 'by accident'
                    },
                    punctuation: [
                        { pattern: /([.,!?;:])([A-Za-z√Ä-√ø])/g, replace: '$1 $2' },
                        { pattern: /(\s){2,}/g, replace: ' ' },
                        { pattern: /(\w)\.(\w)/g, replace: '$1. $2' },
                        { pattern: /(\w),(\w)/g, replace: '$1, $2' }
                    ],
                    capitalization: [
                        { pattern: /\bi\b/g, replace: 'I' },
                        { pattern: /^([a-z])/, replace: (match) => match.toUpperCase() },
                        { pattern: /([.!?]\s+)([a-z])/g, replace: (match, p1, p2) => p1 + p2.toUpperCase() }
                    ]
                },
                'fr': {
                    spelling: {
                        'acheter': 'achet√©',
                        'supermarche': 'supermarch√©',
                        'apr√©ci√©': 'appr√©ci√©',
                        '√©t√©': '√©t√©',
                        'a': '√†',
                        'ou': 'o√π',
                        'la': 'l√†',
                        'se': 'ce',
                        'sa': '√ßa',
                        'de': 'd√©',
                        'sur': 's√ªr',
                        'des': 'd√®s',
                        'du': 'd√ª',
                        'cote': 'c√¥te',
                        'cot√©': 'c√¥t√©',
                        'plutot': 'plut√¥t',
                        't√¥t': 't√¥t',
                        'tard': 'tard',
                        'parce': 'parce que',
                        'quelque': 'quelques',
                        'meme': 'm√™me',
                        'tr√©s': 'tr√®s',
                        'apr√©s': 'apr√®s',
                        'avocat': 'avocat',
                        'pr√©s': 'pr√®s',
                        'si': 'si',
                        'n\'importe': 'n\'importe',
                        'quelqu': 'quelqu\'un',
                        'jusque': 'jusqu\'√†',
                        'lorsque': 'lorsque',
                        'quoique': 'quoique',
                        'parceque': 'parce que',
                        'entrain': 'en train',
                        'autant': 'autant',
                        'cependant': 'cependant',
                        'neanmoins': 'n√©anmoins'
                    },
                    grammar: {
                        'bon': (word, context) => {
                            if (context.prevWord === 'tr√®s' && context.nextWord === 'pommes') return 'bonnes';
                            if (context.prevWord === 'tr√®s') return 'bonne';
                            return word;
                        },
                        'moi et': 'et moi',
                        'toi et': 'et toi',
                        'lui et': 'et lui',
                        'elle et': 'et elle',
                        'nous et': 'et nous',
                        'vous et': 'et vous',
                        'eux et': 'et eux'
                    },
                    punctuation: [
                        { pattern: /([.,!?;:])([A-Za-z√Ä-√ø])/g, replace: '$1 $2' },
                        { pattern: /(\s){2,}/g, replace: ' ' },
                        { pattern: /(\w)\.(\w)/g, replace: '$1. $2' },
                        { pattern: /(\w),(\w)/g, replace: '$1, $2' }
                    ],
                    capitalization: [
                        { pattern: /^([a-z√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º√ß])/, replace: (match) => match.toUpperCase() },
                        { pattern: /([.!?]\s+)([a-z√†√¢√§√©√®√™√´√Æ√Ø√¥√∂√π√ª√º√ß])/g, replace: (match, p1, p2) => p1 + p2.toUpperCase() }
                    ]
                }
            };

            // Advanced style improvements
            const styleImprovements = {
                'en': [
                    { from: 'very good', to: 'excellent', type: 'style' },
                    { from: 'really good', to: 'outstanding', type: 'style' },
                    { from: 'very bad', to: 'terrible', type: 'style' },
                    { from: 'a lot of', to: 'numerous', type: 'formal' },
                    { from: 'lots of', to: 'many', type: 'formal' },
                    { from: 'get', to: 'obtain', type: 'formal' },
                    { from: 'give', to: 'provide', type: 'formal' },
                    { from: 'show', to: 'demonstrate', type: 'formal' },
                    { from: 'tell', to: 'inform', type: 'formal' },
                    { from: 'start', to: 'commence', type: 'formal' },
                    { from: 'end', to: 'conclude', type: 'formal' },
                    { from: 'try', to: 'attempt', type: 'formal' },
                    { from: 'buy', to: 'purchase', type: 'formal' },
                    { from: 'cheap', to: 'inexpensive', type: 'formal' },
                    { from: 'expensive', to: 'costly', type: 'formal' },
                    { from: 'big', to: 'large', type: 'formal' },
                    { from: 'small', to: 'small', type: 'formal' },
                    { from: 'fast', to: 'rapid', type: 'formal' },
                    { from: 'slow', to: 'gradual', type: 'formal' }
                ],
                'fr': [
                    { from: 'tr√®s bon', to: 'excellent', type: 'style' },
                    { from: 'tr√®s mauvais', to: 'd√©plorable', type: 'style' },
                    { from: 'beaucoup de', to: 'nombreux', type: 'formal' },
                    { from: 'donner', to: 'fournir', type: 'formal' },
                    { from: 'montrer', to: 'd√©montrer', type: 'formal' },
                    { from: 'dire', to: 'informer', type: 'formal' },
                    { from: 'commencer', to: 'd√©buter', type: 'formal' },
                    { from: 'finir', to: 'terminer', type: 'formal' },
                    { from: 'essayer', to: 'tenter', type: 'formal' },
                    { from: 'acheter', to: 'acqu√©rir', type: 'formal' },
                    { from: 'pas cher', to: '√©conomique', type: 'formal' },
                    { from: 'cher', to: 'co√ªteux', type: 'formal' },
                    { from: 'grand', to: 'important', type: 'formal' },
                    { from: 'petit', to: 'modeste', type: 'formal' },
                    { from: 'vite', to: 'rapidement', type: 'formal' },
                    { from: 'lent', to: 'progressivement', type: 'formal' }
                ]
            };

            // Initialize
            let currentCorrections = [];
            let detectedLanguage = 'en';
            
            // Update language display
            languageSelect.addEventListener('change', function() {
                const lang = this.value;
                currentLanguage.textContent = `Currently checking: ${this.options[this.selectedIndex].text}`;
                detectedLanguage = lang.startsWith('en') ? 'en' : 'fr';
                processText();
            });

            // Auto-correct button
            autoCorrectBtn.addEventListener('click', processText);

            // Copy corrected text
            copyBtn.addEventListener('click', function() {
                const text = correctedText.innerText;
                if (text) {
                    navigator.clipboard.writeText(text).then(() => {
                        const originalHTML = copyBtn.innerHTML;
                        copyBtn.innerHTML = '‚úÖ Copied!';
                        setTimeout(() => {
                            copyBtn.innerHTML = originalHTML;
                        }, 2000);
                    });
                }
            });

            // Real-time processing
            originalText.addEventListener('input', debounce(processText, 300));

            // Show tooltip on hover
            originalText.addEventListener('mouseover', function(e) {
                if (e.target.classList.contains('error-highlight')) {
                    const error = e.target.getAttribute('data-error');
                    const correction = e.target.getAttribute('data-correction');
                    errorTooltip.innerHTML = `
                        <strong>Error:</strong> ${error}<br>
                        <strong>Corrected to:</strong> ${correction}<br>
                        <em>Click to accept correction</em>
                    `;
                    errorTooltip.style.left = e.pageX + 'px';
                    errorTooltip.style.top = (e.pageY - 40) + 'px';
                    errorTooltip.style.opacity = '1';
                }
            });

            originalText.addEventListener('mousemove', function(e) {
                if (e.target.classList.contains('error-highlight')) {
                    errorTooltip.style.left = e.pageX + 'px';
                    errorTooltip.style.top = (e.pageY - 40) + 'px';
                }
            });

            originalText.addEventListener('mouseout', function() {
                errorTooltip.style.opacity = '0';
            });

            // Click to accept individual correction
            originalText.addEventListener('click', function(e) {
                if (e.target.classList.contains('error-highlight')) {
                    const correction = e.target.getAttribute('data-correction');
                    const range = document.createRange();
                    range.selectNodeContents(e.target);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    document.execCommand('insertText', false, correction);
                    processText();
                }
            });

            // Process text function
            function processText() {
                const text = originalText.innerText;
                const langCode = detectedLanguage;
                
                // Update basic stats
                updateBasicStats(text);
                
                // Reset corrections
                currentCorrections = [];
                correctionsContainer.innerHTML = '';
                
                // Process corrections
                let corrected = text;
                let errorsFound = 0;
                
                // Apply spelling corrections
                Object.entries(correctionRules[langCode].spelling).forEach(([error, correction]) => {
                    const regex = new RegExp(`\\b${error}\\b`, 'gi');
                    const matches = corrected.match(regex);
                    if (matches) {
                        matches.forEach(match => {
                            errorsFound++;
                            currentCorrections.push({
                                from: match,
                                to: typeof correction === 'function' ? correction(match, {}) : correction,
                                type: 'spelling'
                            });
                        });
                        corrected = corrected.replace(regex, typeof correction === 'function' ? correction : correction);
                    }
                });

                // Apply grammar corrections
                Object.entries(correctionRules[langCode].grammar).forEach(([error, correction]) => {
                    const regex = new RegExp(`\\b${error}\\b`, 'gi');
                    const matches = corrected.match(regex);
                    if (matches) {
                        matches.forEach(match => {
                            errorsFound++;
                            const context = getWordContext(corrected, match);
                            const actualCorrection = typeof correction === 'function' ? correction(match, context) : correction;
                            currentCorrections.push({
                                from: match,
                                to: actualCorrection,
                                type: 'grammar'
                            });
                            corrected = corrected.replace(new RegExp(`\\b${match}\\b`, 'gi'), actualCorrection);
                        });
                    }
                });

                // Apply expression corrections
                if (correctionRules[langCode].expressions) {
                    Object.entries(correctionRules[langCode].expressions).forEach(([error, correction]) => {
                        const regex = new RegExp(error, 'gi');
                        const matches = corrected.match(regex);
                        if (matches) {
                            matches.forEach(match => {
                                errorsFound++;
                                currentCorrections.push({
                                    from: match,
                                    to: correction,
                                    type: 'expression'
                                });
                            });
                            corrected = corrected.replace(regex, correction);
                        }
                    });
                }

                // Apply punctuation corrections
                correctionRules[langCode].punctuation.forEach(rule => {
                    const matches = corrected.match(rule.pattern);
                    if (matches) {
                        matches.forEach(match => {
                            errorsFound++;
                            const correction = match.replace(rule.pattern, rule.replace);
                            currentCorrections.push({
                                from: match,
                                to: correction,
                                type: 'punctuation'
                            });
                        });
                        corrected = corrected.replace(rule.pattern, rule.replace);
                    }
                });

                // Apply capitalization corrections
                correctionRules[langCode].capitalization.forEach(rule => {
                    const matches = corrected.match(rule.pattern);
                    if (matches) {
                        matches.forEach(match => {
                            errorsFound++;
                            const correction = typeof rule.replace === 'function' ? match.replace(rule.pattern, rule.replace) : match.replace(rule.pattern, rule.replace);
                            currentCorrections.push({
                                from: match,
                                to: correction,
                                type: 'capitalization'
                            });
                        });
                        corrected = corrected.replace(rule.pattern, rule.replace);
                    }
                });

                // Apply style improvements
                styleImprovements[langCode].forEach(improvement => {
                    const regex = new RegExp(improvement.from, 'gi');
                    const matches = corrected.match(regex);
                    if (matches && Math.random() > 0.3) { // Apply some style improvements randomly
                        matches.forEach(match => {
                            errorsFound++;
                            currentCorrections.push({
                                from: match,
                                to: improvement.to,
                                type: improvement.type
                            });
                        });
                        corrected = corrected.replace(regex, improvement.to);
                    }
                });

                // Update original text with highlights
                highlightErrorsInOriginal(text, currentCorrections);

                // Update corrected text
                correctedText.innerHTML = formatCorrectedText(corrected);

                // Update statistics
                updateStats(errorsFound, currentCorrections.length, text, corrected);

                // Update corrections list
                updateCorrectionsList(currentCorrections);
            }

            function highlightErrorsInOriginal(originalText, corrections) {
                let highlighted = originalText;
                
                // Sort corrections by length (longest first) to avoid overlapping
                const sortedCorrections = [...corrections].sort((a, b) => b.from.length - a.from.length);
                
                sortedCorrections.forEach(correction => {
                    const escapedFrom = escapeRegExp(correction.from);
                    const regex = new RegExp(`(${escapedFrom})`, 'gi');
                    highlighted = highlighted.replace(regex, 
                        `<span class="error-highlight" 
                              data-error="$1" 
                              data-correction="${correction.to}"
                              title="${correction.type}: '$1' ‚Üí '${correction.to}'">
                            $1
                         </span>`);
                });
                
                originalText.innerHTML = highlighted;
            }

            function formatCorrectedText(text) {
                // Add paragraph breaks and formatting
                return text
                    .split('\n\n')
                    .map(paragraph => {
                        if (paragraph.trim() === '') return '<br>';
                        return `<p>${paragraph.replace(/\n/g, '<br>')}</p>`;
                    })
                    .join('');
            }

            function updateBasicStats(text) {
                const words = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;
                const chars = text.length;
                
                wordCount.textContent = words.toLocaleString();
                charCount.textContent = chars.toLocaleString();
            }

            function updateStats(errorsFound, correctionsApplied, originalText, correctedText) {
                errorCount.textContent = errorsFound;
                correctionApplied.textContent = correctionsApplied;
                originalErrorCount.textContent = errorsFound;
                correctionCount.textContent = correctionsApplied;
                
                // Update badges
                errorCountBadge.textContent = `${errorsFound} ${errorsFound === 1 ? 'error' : 'errors'}`;
                errorCountBadge.className = errorsFound > 0 ? 'badge badge-error' : 'badge badge-success';
                
                correctionCountBadge.textContent = `${correctionsApplied} ${correctionsApplied === 1 ? 'correction' : 'corrections'}`;
                correctionCountBadge.className = correctionsApplied > 0 ? 'badge badge-success' : 'badge badge-warning';
                
                // Calculate quality score
                const originalWords = originalText.trim().split(/\s+/).length || 1;
                const quality = Math.max(0, 100 - (errorsFound / originalWords * 100));
                qualityScore.textContent = `${Math.round(quality)}%`;
                
                // Update quality meter
                document.querySelector('.quality-fill').style.width = `${quality}%`;
            }

            function updateCorrectionsList(corrections) {
                correctionsContainer.innerHTML = '';
                
                if (corrections.length === 0) {
                    correctionsContainer.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #4CAF50;">
                            <div style="font-size: 2rem;">üéâ</div>
                            <p>Perfect! No corrections needed.</p>
                        </div>
                    `;
                    return;
                }
                
                // Show first 10 corrections
                corrections.slice(0, 10).forEach(correction => {
                    const div = document.createElement('div');
                    div.className = 'correction-item';
                    div.innerHTML = `
                        <span class="correction-from">${correction.from}</span>
                        <span class="correction-arrow">‚Üí</span>
                        <span class="correction-to">${correction.to}</span>
                        <span class="badge" style="background: ${getTypeColor(correction.type)}">${correction.type}</span>
                    `;
                    correctionsContainer.appendChild(div);
                });
                
                if (corrections.length > 10) {
                    const moreDiv = document.createElement('div');
                    moreDiv.className = 'correction-item';
                    moreDiv.style.textAlign = 'center';
                    moreDiv.style.fontStyle = 'italic';
                    moreDiv.textContent = `... and ${corrections.length - 10} more corrections`;
                    correctionsContainer.appendChild(moreDiv);
                }
            }

            function getTypeColor(type) {
                const colors = {
                    'spelling': '#ff5252',
                    'grammar': '#ff9800',
                    'expression': '#2196F3',
                    'punctuation': '#9C27B0',
                    'capitalization': '#795548',
                    'style': '#4CAF50',
                    'formal': '#607D8B'
                };
                return colors[type] || '#666';
            }

            function getWordContext(text, word) {
                const index = text.toLowerCase().indexOf(word.toLowerCase());
                if (index === -1) return {};
                
                const before = text.substring(Math.max(0, index - 20), index);
                const after = text.substring(index + word.length, Math.min(text.length, index + word.length + 20));
                
                const wordsBefore = before.trim().split(/\s+/);
                const wordsAfter = after.trim().split(/\s+/);
                
                return {
                    prevWord: wordsBefore[wordsBefore.length - 1] || '',
                    nextWord: wordsAfter[0] || '',
                    context: before + word + after
                };
            }

            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Initialize quality meter
            const qualityMeter = document.createElement('div');
            qualityMeter.className = 'quality-meter';
            qualityMeter.innerHTML = '<div class="quality-fill" style="width: 100%"></div>';
            qualityScore.parentNode.insertBefore(qualityMeter, qualityScore.nextSibling);

            // Process initial text
            processText();
        });
    </script>
</body>
</html>
