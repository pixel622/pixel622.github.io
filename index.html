<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Mountain Skiing</title>
    <style>
        /* RESET & BASE STYLES */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* LOADING SCREEN */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a237e, #0d47a1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .loader {
            width: 80px;
            height: 80px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: #4fc3f7;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 30px;
        }
        
        @keyframes spin {
            100% { transform: rotate(360deg); }
        }
        
        #loadingText {
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }
        
        #loadingSubtext {
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            text-align: center;
            padding: 0 20px;
        }
        
        /* MAIN UI CONTAINER */
        #uiContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* TOP UI - SKIING STATS */
        #topUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .ui-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .ui-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 16px;
            font-weight: 600;
        }
        
        .ui-icon {
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        #speedDisplay { color: #4fc3f7; }
        #altitudeDisplay { color: #81c784; }
        #distanceDisplay { color: #ffb74d; }
        #scoreDisplay { color: #ffd700; }
        
        /* SPEED INDICATOR */
        #speedIndicator {
            position: absolute;
            bottom: 180px;
            right: 20px;
            width: 100px;
            height: 100px;
            z-index: 100;
        }
        
        .speed-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }
        
        .speed-fill {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-top-color: #4fc3f7;
            border-radius: 50%;
            clip-path: polygon(50% 50%, 50% 0, 100% 0, 100% 100%, 0 100%, 0 0, 50% 0);
            transform: rotate(45deg);
        }
        
        .speed-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
        }
        
        .speed-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }
        
        /* TILT INDICATOR */
        #tiltIndicator {
            position: absolute;
            bottom: 180px;
            left: 20px;
            width: 100px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }
        
        .tilt-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        .tilt-marker {
            position: absolute;
            width: 4px;
            height: 20px;
            background: rgba(255, 255, 255, 0.5);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .tilt-pointer {
            position: absolute;
            width: 30px;
            height: 4px;
            background: #4fc3f7;
            top: 50%;
            left: 50%;
            transform-origin: left center;
            transform: translateY(-50%);
            transition: transform 0.1s;
        }
        
        .tilt-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            white-space: nowrap;
        }
        
        /* SKI CONTROLS */
        #skiControls {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            z-index: 100;
            pointer-events: none;
        }
        
        .ski-control {
            width: 70px;
            height: 70px;
            background: radial-gradient(circle at 30% 30%, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.9));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            touch-action: none;
            transition: all 0.1s ease;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .ski-control:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }
        
        #leftControl {
            border-color: rgba(76, 175, 80, 0.8);
        }
        
        #rightControl {
            border-color: rgba(244, 67, 54, 0.8);
        }
        
        #jumpControl {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, rgba(33, 150, 243, 0.8), rgba(21, 101, 192, 0.9));
            border-color: rgba(33, 150, 243, 0.9);
            font-size: 28px;
        }
        
        .control-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        
        /* CENTER MESSAGES */
        #centerMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 150;
        }
        
        /* SNOW EFFECT OVERLAY */
        #snowOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0.3;
        }
        
        .snowflake {
            position: absolute;
            background: white;
            border-radius: 50%;
            opacity: 0.8;
            animation: fall linear infinite;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh);
            }
        }
        
        /* PAUSE MENU */
        #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            backdrop-filter: blur(10px);
        }
        
        .pause-title {
            color: white;
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 40px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .menu-btn {
            background: linear-gradient(135deg, #2196f3, #1976d2);
            color: white;
            border: none;
            padding: 15px 40px;
            margin: 10px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 200px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.3);
        }
        
        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(33, 150, 243, 0.4);
        }
        
        .menu-btn:active {
            transform: translateY(0);
        }
        
        #resumeBtn { background: linear-gradient(135deg, #4caf50, #388e3c); }
        #restartBtn { background: linear-gradient(135deg, #ff9800, #f57c00); }
        #quitBtn { background: linear-gradient(135deg, #f44336, #d32f2f); }
        
        /* INSTRUCTIONS */
        #instructions {
            position: absolute;
            bottom: 300px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 15px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: fadeOut 5s 10s forwards;
        }
        
        @keyframes fadeOut {
            to { opacity: 0; visibility: hidden; }
        }
        
        /* GAME OVER SCREEN */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            backdrop-filter: blur(20px);
        }
        
        .game-over-title {
            color: #4fc3f7;
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }
        
        .final-stats {
            color: white;
            font-size: 24px;
            margin: 10px 0;
            text-align: center;
        }
        
        .stat-value {
            color: #ffd700;
            font-weight: bold;
        }
        
        /* RESPONSIVE */
        @media (max-width: 768px) {
            .ski-control {
                width: 60px;
                height: 60px;
                font-size: 20px;
            }
            
            #jumpControl {
                width: 70px;
                height: 70px;
                font-size: 24px;
            }
            
            #speedIndicator, #tiltIndicator {
                bottom: 160px;
            }
            
            .pause-title {
                font-size: 28px;
            }
            
            .menu-btn {
                width: 180px;
                padding: 12px 30px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .ski-control {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
            
            #jumpControl {
                width: 60px;
                height: 60px;
                font-size: 20px;
            }
            
            #speedIndicator, #tiltIndicator {
                bottom: 140px;
                width: 80px;
                height: 80px;
            }
            
            #tiltIndicator {
                height: 50px;
                width: 80px;
            }
            
            #topUI {
                padding: 10px;
            }
            
            .ui-item {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- LOADING SCREEN -->
    <div id="loadingScreen">
        <div class="loader"></div>
        <div id="loadingText">Loading Mountain Skiing...</div>
        <div id="loadingSubtext">Touch screen to begin your descent</div>
    </div>
    
    <!-- CANVAS -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- SNOW OVERLAY -->
    <div id="snowOverlay"></div>
    
    <!-- UI CONTAINER -->
    <div id="uiContainer">
        <!-- TOP UI -->
        <div id="topUI">
            <div class="ui-section">
                <div class="ui-item">
                    <div class="ui-icon">‚ö°</div>
                    <div id="speedDisplay">Speed: 0 km/h</div>
                </div>
                <div class="ui-item">
                    <div class="ui-icon">‚õ∞Ô∏è</div>
                    <div id="altitudeDisplay">Altitude: 1000m</div>
                </div>
            </div>
            
            <div class="ui-section">
                <div class="ui-item">
                    <div class="ui-icon">üìè</div>
                    <div id="distanceDisplay">Distance: 0m</div>
                </div>
                <div class="ui-item">
                    <div class="ui-icon">‚≠ê</div>
                    <div id="scoreDisplay">Score: 0</div>
                </div>
            </div>
        </div>
        
        <!-- SPEED INDICATOR -->
        <div id="speedIndicator">
            <div class="speed-circle"></div>
            <div class="speed-fill" id="speedFill"></div>
            <div class="speed-text">
                <span id="speedValue">0</span>
                <div class="speed-label">KM/H</div>
            </div>
        </div>
        
        <!-- TILT INDICATOR -->
        <div id="tiltIndicator">
            <div class="tilt-line"></div>
            <div class="tilt-marker"></div>
            <div class="tilt-pointer" id="tiltPointer"></div>
            <div class="tilt-label">TILT</div>
        </div>
        
        <!-- SKI CONTROLS -->
        <div id="skiControls">
            <div class="ski-control" id="leftControl">
                ‚Üê
                <div class="control-label">LEFT</div>
            </div>
            <div class="ski-control" id="rightControl">
                ‚Üí
                <div class="control-label">RIGHT</div>
            </div>
        </div>
        
        <!-- JUMP CONTROL -->
        <div class="ski-control" id="jumpControl">
            ü¶ò
            <div class="control-label">JUMP</div>
        </div>
        
        <!-- CENTER MESSAGE -->
        <div id="centerMessage"></div>
        
        <!-- INSTRUCTIONS -->
        <div id="instructions">
            <div>Use LEFT/RIGHT buttons to steer</div>
            <div>Press JUMP for tricks</div>
            <div>Ski down the mountain as far as you can!</div>
        </div>
    </div>
    
    <!-- PAUSE MENU -->
    <div id="pauseMenu">
        <div class="pause-title">SKIING PAUSED</div>
        <button class="menu-btn" id="resumeBtn">RESUME</button>
        <button class="menu-btn" id="restartBtn">RESTART RUN</button>
        <button class="menu-btn" id="quitBtn">QUIT</button>
    </div>
    
    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen">
        <div class="game-over-title">RUN COMPLETE</div>
        <div class="final-stats">Distance: <span class="stat-value" id="finalDistance">0m</span></div>
        <div class="final-stats">Top Speed: <span class="stat-value" id="finalSpeed">0 km/h</span></div>
        <div class="final-stats">Score: <span class="stat-value" id="finalScore">0</span></div>
        <div class="final-stats">Jumps: <span class="stat-value" id="finalJumps">0</span></div>
        <button class="menu-btn" id="playAgainBtn">SKI AGAIN</button>
        <button class="menu-btn" id="menuBtn">MAIN MENU</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==================== GAME CONFIGURATION ====================
        const GameConfig = {
            skiing: {
                baseSpeed: 5,
                maxSpeed: 120,
                acceleration: 8,
                deceleration: 3,
                turnSpeed: 2.5,
                jumpForce: 8,
                gravity: 15,
                airControl: 0.5,
                slopeAcceleration: 10,
                friction: 0.95
            },
            mountain: {
                width: 200,
                length: 1000,
                height: 300,
                peakHeight: 350,
                snowLevel: 0.7,
                treeDensity: 0.01,
                rockDensity: 0.005
            },
            scoring: {
                distanceMultiplier: 1,
                speedMultiplier: 2,
                jumpMultiplier: 10,
                trickMultiplier: 50,
                comboMultiplier: 1.5
            },
            visuals: {
                fogDensity: 0.002,
                snowflakeCount: 100,
                particleCount: 20
            }
        };

        // ==================== GLOBAL VARIABLES ====================
        let scene, camera, renderer, controls;
        let game, buttonController;
        let deltaTime = 0;
        let gameTime = 0;
        let isGameStarted = false;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let snowflakes = [];

        // ==================== BUTTON CONTROLLER ====================
        class ButtonController {
            constructor() {
                this.buttons = {
                    left: false,
                    right: false,
                    jump: false
                };
                
                this.buttonElements = {};
                this.init();
            }
            
            init() {
                const buttons = ['leftControl', 'rightControl', 'jumpControl'];
                
                buttons.forEach(btnId => {
                    const element = document.getElementById(btnId);
                    const buttonName = btnId.replace('Control', '');
                    this.buttonElements[buttonName] = element;
                    
                    // Touch events
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.buttons[buttonName] = true;
                        element.style.transform = 'scale(0.85)';
                        element.style.opacity = '0.8';
                    }, { passive: false });
                    
                    element.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.buttons[buttonName] = false;
                        element.style.transform = 'scale(1)';
                        element.style.opacity = '1';
                    }, { passive: false });
                    
                    element.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        this.buttons[buttonName] = false;
                        element.style.transform = 'scale(1)';
                        element.style.opacity = '1';
                    }, { passive: false });
                    
                    // Mouse events for testing
                    if (!isMobile) {
                        element.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            this.buttons[buttonName] = true;
                            element.style.transform = 'scale(0.85)';
                            element.style.opacity = '0.8';
                        });
                        
                        element.addEventListener('mouseup', (e) => {
                            e.preventDefault();
                            this.buttons[buttonName] = false;
                            element.style.transform = 'scale(1)';
                            element.style.opacity = '1';
                        });
                        
                        element.addEventListener('mouseleave', (e) => {
                            e.preventDefault();
                            this.buttons[buttonName] = false;
                            element.style.transform = 'scale(1)';
                            element.style.opacity = '1';
                        });
                    }
                });
                
                // Pause button (double tap on screen)
                let lastTap = 0;
                document.addEventListener('touchstart', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    
                    if (tapLength < 300 && tapLength > 0) {
                        e.preventDefault();
                        game.togglePause();
                    }
                    lastTap = currentTime;
                });
            }
            
            isPressed(buttonName) {
                return this.buttons[buttonName];
            }
            
            getAllButtons() {
                return { ...this.buttons };
            }
        }

        // ==================== SNOW EFFECT ====================
        class SnowEffect {
            constructor() {
                this.container = document.getElementById('snowOverlay');
                this.snowflakes = [];
                this.createSnowflakes();
            }
            
            createSnowflakes() {
                for (let i = 0; i < GameConfig.visuals.snowflakeCount; i++) {
                    const snowflake = document.createElement('div');
                    snowflake.className = 'snowflake';
                    
                    const size = Math.random() * 5 + 2;
                    const startX = Math.random() * 100;
                    const duration = Math.random() * 10 + 5;
                    const delay = Math.random() * 5;
                    const opacity = Math.random() * 0.5 + 0.3;
                    
                    snowflake.style.width = `${size}px`;
                    snowflake.style.height = `${size}px`;
                    snowflake.style.left = `${startX}%`;
                    snowflake.style.opacity = opacity;
                    snowflake.style.animationDuration = `${duration}s`;
                    snowflake.style.animationDelay = `${delay}s`;
                    
                    this.container.appendChild(snowflake);
                    this.snowflakes.push({
                        element: snowflake,
                        x: startX,
                        speed: duration,
                        size: size
                    });
                }
            }
            
            update(intensity = 1) {
                this.snowflakes.forEach(snowflake => {
                    // Reset snowflake if it's off screen
                    const rect = snowflake.element.getBoundingClientRect();
                    if (rect.top > window.innerHeight) {
                        snowflake.element.style.top = '-10px';
                        snowflake.element.style.left = `${Math.random() * 100}%`;
                    }
                    
                    // Adjust speed based on intensity
                    snowflake.element.style.animationDuration = `${snowflake.speed / intensity}s`;
                });
            }
        }

        // ==================== SKIER CLASS ====================
        class Skier {
            constructor() {
                // First-person view - no visible player model
                this.mesh = new THREE.Object3D();
                this.mesh.position.set(0, GameConfig.mountain.peakHeight - 10, -GameConfig.mountain.length / 4);
                
                // Ski physics
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.direction = new THREE.Vector3(0, 0, 1); // Start facing downhill
                this.speed = 0;
                this.turnAngle = 0;
                this.turnSpeed = GameConfig.skiing.turnSpeed;
                this.isOnGround = true;
                this.isJumping = false;
                this.jumpCooldown = 0;
                
                // Ski poles (visual only, not rendered)
                this.leftPole = new THREE.Vector3(-0.5, 0, 1);
                this.rightPole = new THREE.Vector3(0.5, 0, 1);
                
                // Stats
                this.distance = 0;
                this.maxSpeed = 0;
                this.jumpCount = 0;
                this.trickCount = 0;
                this.combo = 0;
                this.score = 0;
                
                // Ski tracks
                this.trackPositions = [];
                this.trackMesh = this.createTrackMesh();
                scene.add(this.trackMesh);
                
                // Particle system for snow spray
                this.particleSystem = this.createParticleSystem();
                scene.add(this.particleSystem);
                
                // Add to scene
                scene.add(this.mesh);
            }
            
            createTrackMesh() {
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    linewidth: 2
                });
                return new THREE.Line(geometry, material);
            }
            
            createParticleSystem() {
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.2,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                return new THREE.Points(geometry, material);
            }
            
            update(deltaTime) {
                // Update cooldowns
                if (this.jumpCooldown > 0) this.jumpCooldown -= deltaTime;
                
                // Handle input
                this.handleSteering(deltaTime);
                
                // Apply physics
                this.applyPhysics(deltaTime);
                
                // Update position
                this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Get terrain height at current position
                const terrainHeight = game.getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
                
                // Ground collision
                if (this.mesh.position.y <= terrainHeight + 0.5) {
                    this.mesh.position.y = terrainHeight + 0.5;
                    this.velocity.y = 0;
                    this.isOnGround = true;
                    this.isJumping = false;
                    
                    // Add snow spray particles when moving fast
                    if (this.speed > 20) {
                        this.createSnowSpray();
                    }
                } else {
                    // In air - apply gravity
                    this.velocity.y -= GameConfig.skiing.gravity * deltaTime;
                    this.isOnGround = false;
                }
                
                // Calculate slope angle for acceleration
                const slopeVector = game.getSlopeVector(this.mesh.position.x, this.mesh.position.z);
                const slopeAngle = Math.acos(Math.abs(slopeVector.y));
                
                // Accelerate based on slope
                if (this.isOnGround && slopeAngle > 0.1) {
                    const slopeAcceleration = GameConfig.skiing.slopeAcceleration * Math.sin(slopeAngle);
                    this.speed += slopeAcceleration * deltaTime;
                }
                
                // Apply friction
                if (this.isOnGround) {
                    this.speed *= GameConfig.skiing.friction;
                }
                
                // Limit speed
                this.speed = Math.min(this.speed, GameConfig.skiing.maxSpeed);
                
                // Update velocity based on speed and direction
                this.velocity.x = Math.sin(this.turnAngle) * this.speed;
                this.velocity.z = Math.cos(this.turnAngle) * this.speed;
                
                // Update distance
                const distanceTraveled = this.velocity.length() * deltaTime;
                this.distance += distanceTraveled;
                
                // Update max speed
                if (this.speed > this.maxSpeed) {
                    this.maxSpeed = this.speed;
                }
                
                // Update score
                this.updateScore(deltaTime);
                
                // Update tracks
                this.updateTracks();
                
                // Update particles
                this.updateParticles(deltaTime);
                
                // Update tilt indicator
                this.updateTiltIndicator();
                
                // Check if fallen off mountain
                if (this.mesh.position.y < -100) {
                    game.endRun();
                }
            }
            
            handleSteering(deltaTime) {
                // Get button states
                const buttons = buttonController.getAllButtons();
                
                // Turning
                if (buttons.left) {
                    this.turnAngle += this.turnSpeed * deltaTime;
                }
                if (buttons.right) {
                    this.turnAngle -= this.turnSpeed * deltaTime;
                }
                
                // Normalize turn angle
                this.turnAngle = (this.turnAngle + Math.PI * 2) % (Math.PI * 2);
                
                // Jumping
                if (buttons.jump && this.jumpCooldown <= 0) {
                    this.jump();
                }
                
                // Apply turning to direction
                this.direction.x = Math.sin(this.turnAngle);
                this.direction.z = Math.cos(this.turnAngle);
                this.direction.normalize();
            }
            
            applyPhysics(deltaTime) {
                // If in air, allow some air control
                if (!this.isOnGround) {
                    const airControl = GameConfig.skiing.airControl;
                    if (buttonController.isPressed('left')) {
                        this.turnAngle += this.turnSpeed * airControl * deltaTime;
                    }
                    if (buttonController.isPressed('right')) {
                        this.turnAngle -= this.turnSpeed * airControl * deltaTime;
                    }
                }
                
                // Update combo based on air time
                if (!this.isOnGround) {
                    this.combo += deltaTime * 10;
                } else if (this.combo > 0) {
                    // Add score for completed combo
                    const comboScore = Math.floor(this.combo * GameConfig.scoring.comboMultiplier);
                    this.score += comboScore;
                    this.combo = 0;
                }
            }
            
            jump() {
                if (this.isOnGround && this.jumpCooldown <= 0) {
                    this.velocity.y = GameConfig.skiing.jumpForce;
                    this.isOnGround = false;
                    this.isJumping = true;
                    this.jumpCooldown = 1;
                    this.jumpCount++;
                    
                    // Add jump score
                    const jumpScore = GameConfig.scoring.jumpMultiplier * (1 + this.speed / 50);
                    this.score += Math.floor(jumpScore);
                    
                    // Show jump text
                    game.createFloatingText(this.mesh.position, 'JUMP!', 0x4fc3f7);
                    
                    return true;
                }
                return false;
            }
            
            createSnowSpray() {
                // Create snow spray particles
                const particleCount = Math.floor(this.speed / 10);
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 0.5;
                    const height = Math.random() * 0.3;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = height;
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    velocities[i * 3] = (Math.random() - 0.5) * 2;
                    velocities[i * 3 + 1] = Math.random() * 3;
                    velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                }
                
                // Store particle data
                this.particleSystem.userData.positions = positions;
                this.particleSystem.userData.velocities = velocities;
                this.particleSystem.userData.lifetimes = new Float32Array(particleCount).fill(1);
                
                // Update geometry
                this.particleSystem.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            }
            
            updateParticles(deltaTime) {
                if (!this.particleSystem.userData.positions) return;
                
                const positions = this.particleSystem.userData.positions;
                const velocities = this.particleSystem.userData.velocities;
                const lifetimes = this.particleSystem.userData.lifetimes;
                
                for (let i = 0; i < positions.length / 3; i++) {
                    lifetimes[i] -= deltaTime;
                    
                    if (lifetimes[i] <= 0) continue;
                    
                    positions[i * 3] += velocities[i * 3] * deltaTime;
                    positions[i * 3 + 1] += velocities[i * 3 + 1] * deltaTime;
                    positions[i * 3 + 2] += velocities[i * 3 + 2] * deltaTime;
                    
                    velocities[i * 3 + 1] -= 5 * deltaTime; // Gravity
                }
                
                this.particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            updateTracks() {
                // Add current position to track
                this.trackPositions.push(this.mesh.position.clone());
                
                // Limit track length
                if (this.trackPositions.length > 100) {
                    this.trackPositions.shift();
                }
                
                // Update track mesh
                if (this.trackPositions.length > 1) {
                    const positions = new Float32Array(this.trackPositions.length * 3);
                    this.trackPositions.forEach((pos, i) => {
                        positions[i * 3] = pos.x;
                        positions[i * 3 + 1] = pos.y + 0.1; // Slightly above ground
                        positions[i * 3 + 2] = pos.z;
                    });
                    
                    this.trackMesh.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    this.trackMesh.geometry.attributes.position.needsUpdate = true;
                }
            }
            
            updateScore(deltaTime) {
                // Score for distance
                const distanceScore = this.speed * GameConfig.scoring.distanceMultiplier * deltaTime;
                
                // Score for speed
                const speedScore = this.speed * GameConfig.scoring.speedMultiplier * deltaTime;
                
                // Total score
                this.score += Math.floor(distanceScore + speedScore);
            }
            
            updateTiltIndicator() {
                const tiltPointer = document.getElementById('tiltPointer');
                if (tiltPointer) {
                    // Calculate tilt based on turn angle and slope
                    const slopeVector = game.getSlopeVector(this.mesh.position.x, this.mesh.position.z);
                    const tiltAngle = this.turnAngle * 0.5 + (slopeVector.x * 30);
                    const tiltDegrees = THREE.MathUtils.radToDeg(tiltAngle) % 360;
                    
                    // Update pointer rotation
                    tiltPointer.style.transform = `translateY(-50%) rotate(${tiltDegrees}deg)`;
                }
            }
            
            getAltitude() {
                return this.mesh.position.y;
            }
            
            getSpeedKmh() {
                return Math.floor(this.speed * 3.6); // Convert m/s to km/h
            }
            
            updateUI() {
                // Update speed display
                document.getElementById('speedDisplay').textContent = `Speed: ${this.getSpeedKmh()} km/h`;
                document.getElementById('altitudeDisplay').textContent = `Altitude: ${Math.floor(this.getAltitude())}m`;
                document.getElementById('distanceDisplay').textContent = `Distance: ${Math.floor(this.distance)}m`;
                document.getElementById('scoreDisplay').textContent = `Score: ${this.score}`;
                
                // Update speed indicator
                const speedFill = document.getElementById('speedFill');
                const speedValue = document.getElementById('speedValue');
                
                const speedPercent = this.getSpeedKmh() / GameConfig.skiing.maxSpeed;
                const rotation = 45 + (speedPercent * 270); // 45 to 315 degrees
                
                speedFill.style.transform = `rotate(${rotation}deg)`;
                speedValue.textContent = this.getSpeedKmh();
                
                // Update speed fill color based on speed
                if (this.getSpeedKmh() < 30) {
                    speedFill.style.borderTopColor = '#4fc3f7'; // Blue
                } else if (this.getSpeedKmh() < 60) {
                    speedFill.style.borderTopColor = '#4caf50'; // Green
                } else if (this.getSpeedKmh() < 90) {
                    speedFill.style.borderTopColor = '#ff9800'; // Orange
                } else {
                    speedFill.style.borderTopColor = '#f44336'; // Red
                }
            }
            
            reset() {
                this.mesh.position.set(0, GameConfig.mountain.peakHeight - 10, -GameConfig.mountain.length / 4);
                this.velocity.set(0, 0, 0);
                this.speed = GameConfig.skiing.baseSpeed;
                this.turnAngle = 0;
                this.distance = 0;
                this.jumpCount = 0;
                this.trickCount = 0;
                this.combo = 0;
                this.score = 0;
                this.trackPositions = [];
                this.isOnGround = true;
                this.isJumping = false;
            }
        }

        // ==================== MOUNTAIN TERRAIN ====================
        class MountainTerrain {
            constructor() {
                this.geometry = null;
                this.mesh = null;
                this.heightData = null;
                this.createTerrain();
            }
            
            createTerrain() {
                const width = GameConfig.mountain.width;
                const length = GameConfig.mountain.length;
                const height = GameConfig.mountain.height;
                const peakHeight = GameConfig.mountain.peakHeight;
                
                // Create plane geometry
                const geometry = new THREE.PlaneGeometry(width, length, 100, 200);
                
                // Generate height data
                this.heightData = new Float32Array(geometry.attributes.position.count);
                const positions = geometry.attributes.position;
                
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const z = positions.getZ(i);
                    
                    // Base mountain shape (cone)
                    let y = peakHeight - Math.sqrt(x * x + z * z) * 0.5;
                    
                    // Add some randomness for realism
                    y += Math.sin(x * 0.1) * 10;
                    y += Math.cos(z * 0.08) * 8;
                    
                    // Add ridges
                    y += Math.sin(Math.atan2(z, x) * 10) * 5;
                    
                    // Ensure minimum height
                    y = Math.max(0, y);
                    
                    this.heightData[i] = y;
                    positions.setY(i, y);
                }
                
                geometry.computeVertexNormals();
                
                // Create material
                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    roughness: 0.8,
                    metalness: 0.1
                });
                
                // Set vertex colors based on height (snow at top)
                const colors = new Float32Array(positions.count * 3);
                for (let i = 0; i < positions.count; i++) {
                    const y = positions.getY(i);
                    const snowLevel = GameConfig.mountain.snowLevel * peakHeight;
                    
                    let color;
                    if (y > snowLevel) {
                        // Snow
                        const snowIntensity = (y - snowLevel) / (peakHeight - snowLevel);
                        color = new THREE.Color(0xffffff).lerp(new THREE.Color(0xe0e0e0), snowIntensity);
                    } else if (y > snowLevel * 0.7) {
                        // Rocky terrain
                        color = new THREE.Color(0x795548);
                    } else {
                        // Forest/grass
                        color = new THREE.Color(0x2e7d32);
                    }
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Create mesh
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2;
                this.mesh.receiveShadow = true;
                this.mesh.castShadow = true;
                this.mesh.name = 'Mountain';
                
                scene.add(this.mesh);
                
                // Add trees
                this.addTrees();
                
                // Add rocks
                this.addRocks();
            }
            
            addTrees() {
                const treeTrunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
                const treeLeavesGeometry = new THREE.ConeGeometry(1.5, 3, 8);
                
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 });
                const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 });
                
                const treeCount = Math.floor(GameConfig.mountain.width * GameConfig.mountain.length * GameConfig.mountain.treeDensity);
                
                for (let i = 0; i < treeCount; i++) {
                    const x = (Math.random() - 0.5) * GameConfig.mountain.width * 0.8;
                    const z = (Math.random() - 0.5) * GameConfig.mountain.length * 0.8;
                    const y = this.getHeight(x, z);
                    
                    // Only add trees below snow line
                    if (y < GameConfig.mountain.snowLevel * GameConfig.mountain.peakHeight * 0.9) {
                        const trunk = new THREE.Mesh(treeTrunkGeometry, trunkMaterial);
                        const leaves = new THREE.Mesh(treeLeavesGeometry, leavesMaterial);
                        
                        trunk.position.set(x, y + 1.5, z);
                        leaves.position.set(x, y + 3.5, z);
                        
                        // Random rotation
                        const rotation = Math.random() * Math.PI * 2;
                        trunk.rotation.y = rotation;
                        leaves.rotation.y = rotation;
                        
                        // Random scale variation
                        const scale = 0.8 + Math.random() * 0.4;
                        trunk.scale.setScalar(scale);
                        leaves.scale.setScalar(scale);
                        
                        trunk.castShadow = true;
                        leaves.castShadow = true;
                        
                        scene.add(trunk);
                        scene.add(leaves);
                    }
                }
            }
            
            addRocks() {
                const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
                const rockMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x795548,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const rockCount = Math.floor(GameConfig.mountain.width * GameConfig.mountain.length * GameConfig.mountain.rockDensity);
                
                for (let i = 0; i < rockCount; i++) {
                    const x = (Math.random() - 0.5) * GameConfig.mountain.width * 0.9;
                    const z = (Math.random() - 0.5) * GameConfig.mountain.length * 0.9;
                    const y = this.getHeight(x, z);
                    
                    // Rocks can be anywhere
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(x, y + 0.5, z);
                    
                    // Random rotation and scale
                    rock.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );
                    
                    const scale = 0.5 + Math.random() * 2;
                    rock.scale.setScalar(scale);
                    
                    rock.castShadow = true;
                    scene.add(rock);
                }
            }
            
            getHeight(x, z) {
                // Simple interpolation for height
                const width = GameConfig.mountain.width;
                const length = GameConfig.mountain.length;
                
                // Convert to normalized coordinates
                const nx = (x / width) + 0.5;
                const nz = (z / length) + 0.5;
                
                // Clamp to valid range
                if (nx < 0 || nx > 1 || nz < 0 || nz > 1) {
                    return 0;
                }
                
                // Simple approximation - in a real game, you'd use proper interpolation
                // with the height data
                const distanceFromPeak = Math.sqrt(x * x + z * z);
                let height = GameConfig.mountain.peakHeight - distanceFromPeak * 0.5;
                
                // Add some terrain variation
                height += Math.sin(x * 0.1) * 10;
                height += Math.cos(z * 0.08) * 8;
                
                return Math.max(0, height);
            }
            
            getSlopeVector(x, z) {
                // Calculate approximate slope at position
                const delta = 0.1;
                const height = this.getHeight(x, z);
                const heightX = this.getHeight(x + delta, z);
                const heightZ = this.getHeight(x, z + delta);
                
                const slopeX = (heightX - height) / delta;
                const slopeZ = (heightZ - height) / delta;
                
                return new THREE.Vector3(-slopeX, 1, -slopeZ).normalize();
            }
        }

        // ==================== GAME CLASS ====================
        class Game {
            constructor() {
                this.skier = null;
                this.terrain = null;
                this.snowEffect = null;
                this.clock = new THREE.Clock();
                this.isPaused = false;
                this.isGameOver = false;
                this.floatingTexts = [];
                
                this.init();
            }
            
            async init() {
                // Initialize Three.js
                this.initThreeJS();
                
                // Initialize controllers
                buttonController = new ButtonController();
                
                // Initialize terrain
                this.terrain = new MountainTerrain();
                
                // Initialize skier
                this.skier = new Skier();
                
                // Initialize snow effect
                this.snowEffect = new SnowEffect();
                
                // Start game loop
                this.startGame();
                
                // Hide loading screen
                this.hideLoadingScreen();
            }
            
            initThreeJS() {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                scene.fog = new THREE.Fog(0x87ceeb, 50, 500);
                
                // Camera (FIRST PERSON - attached to skier)
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                camera.position.set(0, 1.7, 0); // Eye height
                
                // Renderer
                const canvas = document.getElementById('gameCanvas');
                renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                
                // Lighting
                // Sun light
                const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                sunLight.position.set(100, 200, 100);
                sunLight.castShadow = true;
                sunLight.shadow.camera.left = -100;
                sunLight.shadow.camera.right = 100;
                sunLight.shadow.camera.top = 100;
                sunLight.shadow.camera.bottom = -100;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                scene.add(sunLight);
                
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                
                // Sky light (blue-ish for snow)
                const skyLight = new THREE.HemisphereLight(0x87ceeb, 0x3a3a3a, 0.3);
                scene.add(skyLight);
                
                // Window resize handler
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            hideLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                loadingScreen.style.opacity = '0';
                
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                    this.showCenterMessage('READY TO SKI', 0x4fc3f7, 2);
                    
                    // Start on touch
                    document.addEventListener('touchstart', () => {
                        if (!isGameStarted) {
                            isGameStarted = true;
                            this.showCenterMessage('GO!', 0x4caf50, 1);
                        }
                    }, { once: true });
                    
                    // Also start on click for testing
                    document.addEventListener('click', () => {
                        if (!isGameStarted) {
                            isGameStarted = true;
                            this.showCenterMessage('GO!', 0x4caf50, 1);
                        }
                    }, { once: true });
                }, 500);
            }
            
            getTerrainHeight(x, z) {
                return this.terrain.getHeight(x, z);
            }
            
            getSlopeVector(x, z) {
                return this.terrain.getSlopeVector(x, z);
            }
            
            updateCamera() {
                // First-person camera follows skier
                camera.position.copy(this.skier.mesh.position);
                camera.position.y += 1.7; // Eye height
                
                // Look in direction of movement with some smoothing
                const lookTarget = this.skier.mesh.position.clone().add(this.skier.direction.clone().multiplyScalar(10));
                lookTarget.y = camera.position.y - 1; // Look slightly downhill
                
                camera.lookAt(lookTarget);
                
                // Add slight camera bob when skiing
                if (this.skier.isOnGround && this.skier.speed > 10) {
                    const bob = Math.sin(gameTime * 10) * 0.05;
                    camera.position.y += bob;
                }
                
                // Add head tilt when turning
                const tilt = this.skier.turnAngle * 0.1;
                camera.rotation.z = tilt;
            }
            
            createFloatingText(position, text, color) {
                const floatingText = {
                    element: document.createElement('div'),
                    position: position.clone(),
                    life: 2,
                    velocity: new THREE.Vector3(0, 2, 0)
                };
                
                floatingText.element.style.position = 'absolute';
                floatingText.element.style.color = `#${color.toString(16).padStart(6, '0')}`;
                floatingText.element.style.fontSize = '20px';
                floatingText.element.style.fontWeight = 'bold';
                floatingText.element.style.textShadow = '0 2px 4px rgba(0,0,0,0.5)';
                floatingText.element.style.whiteSpace = 'nowrap';
                floatingText.element.textContent = text;
                
                document.getElementById('uiContainer').appendChild(floatingText.element);
                this.floatingTexts.push(floatingText);
            }
            
            updateFloatingTexts(deltaTime) {
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    text.life -= deltaTime;
                    
                    if (text.life <= 0) {
                        text.element.remove();
                        this.floatingTexts.splice(i, 1);
                        continue;
                    }
                    
                    // Update position
                    text.position.add(text.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Convert world position to screen position
                    const screenPos = text.position.clone().project(camera);
                    
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    
                    text.element.style.left = `${x}px`;
                    text.element.style.top = `${y}px`;
                    text.element.style.opacity = text.life;
                }
            }
            
            showCenterMessage(text, color = 0xffffff, duration = 2) {
                const message = document.getElementById('centerMessage');
                message.textContent = text;
                message.style.color = `#${color.toString(16).padStart(6, '0')}`;
                message.style.opacity = '1';
                
                setTimeout(() => {
                    message.style.opacity = '0';
                }, duration * 1000);
            }
            
            endRun() {
                if (this.isGameOver) return;
                
                this.isGameOver = true;
                this.showGameOverScreen();
            }
            
            showGameOverScreen() {
                document.getElementById('finalDistance').textContent = `${Math.floor(this.skier.distance)}m`;
                document.getElementById('finalSpeed').textContent = `${this.skier.getSpeedKmh()} km/h`;
                document.getElementById('finalScore').textContent = this.skier.score;
                document.getElementById('finalJumps').textContent = this.skier.jumpCount;
                
                document.getElementById('gameOverScreen').style.display = 'flex';
                
                // Setup game over buttons
                document.getElementById('playAgainBtn').onclick = () => {
                    this.restartGame();
                };
                
                document.getElementById('menuBtn').onclick = () => {
                    location.reload();
                };
            }
            
            togglePause() {
                if (this.isGameOver) return;
                
                this.isPaused = !this.isPaused;
                document.getElementById('pauseMenu').style.display = this.isPaused ? 'flex' : 'none';
                
                if (this.isPaused) {
                    this.showCenterMessage('PAUSED', 0xff9800, 999);
                }
            }
            
            restartGame() {
                // Reset game state
                this.isGameOver = false;
                this.isPaused = false;
                
                // Reset skier
                this.skier.reset();
                
                // Clear floating texts
                this.floatingTexts.forEach(text => text.element.remove());
                this.floatingTexts = [];
                
                // Hide screens
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('pauseMenu').style.display = 'none';
                
                // Show start message
                this.showCenterMessage('GO!', 0x4caf50, 2);
            }
            
            startGame() {
                // Setup pause menu buttons
                document.getElementById('resumeBtn').onclick = () => this.togglePause();
                document.getElementById('restartBtn').onclick = () => this.restartGame();
                document.getElementById('quitBtn').onclick = () => location.reload();
                
                // Start game loop
                this.gameLoop();
            }
            
            gameLoop() {
                requestAnimationFrame(() => this.gameLoop());
                
                deltaTime = Math.min(this.clock.getDelta(), 0.1);
                gameTime += deltaTime;
                
                if (!isGameStarted || this.isGameOver) return;
                
                if (!this.isPaused) {
                    // Update skier
                    this.skier.update(deltaTime);
                    
                    // Update camera (first-person follows skier)
                    this.updateCamera();
                    
                    // Update UI
                    this.skier.updateUI();
                    
                    // Update snow effect based on speed
                    const snowIntensity = 0.5 + (this.skier.speed / GameConfig.skiing.maxSpeed) * 0.5;
                    this.snowEffect.update(snowIntensity);
                    
                    // Update floating texts
                    this.updateFloatingTexts(deltaTime);
                }
                
                // Render scene
                renderer.render(scene, camera);
            }
        }

        // ==================== INITIALIZE GAME ====================
        window.addEventListener('load', () => {
            try {
                console.log('Initializing Mountain Skiing Game...');
                console.log('First-person skiing on snowy mountain');
                console.log('Controls: LEFT/RIGHT to steer, JUMP for tricks');
                console.log('Double-tap screen to pause');
                
                game = new Game();
                window.game = game; // For debugging
                
            } catch (error) {
                console.error('Game initialization error:', error);
                
                // Show error message
                document.getElementById('loadingText').textContent = 'Loading Failed';
                document.getElementById('loadingSubtext').textContent = 'Please refresh the page';
                document.getElementById('loadingSubtext').style.color = '#ff4444';
                
                // Remove loader
                document.querySelector('.loader').style.display = 'none';
                
                // Add retry button
                const retryBtn = document.createElement('button');
                retryBtn.textContent = 'RETRY';
                retryBtn.style.background = '#2196f3';
                retryBtn.style.color = 'white';
                retryBtn.style.border = 'none';
                retryBtn.style.padding = '15px 30px';
                retryBtn.style.borderRadius = '25px';
                retryBtn.style.fontSize = '18px';
                retryBtn.style.marginTop = '20px';
                retryBtn.style.cursor = 'pointer';
                retryBtn.onclick = () => location.reload();
                
                document.getElementById('loadingScreen').appendChild(retryBtn);
            }
        });

        // ==================== ERROR HANDLING ====================
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            event.preventDefault();
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            event.preventDefault();
        });

        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target.classList.contains('ski-control')) {
                e.preventDefault();
            }
        }, { passive: false });

    </script>
</body>
</html>
