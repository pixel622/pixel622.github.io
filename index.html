<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Game with Joystick Controls</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        #gameCanvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
        }
        
        /* Joystick Controls */
        #joystickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 200px;
            height: 200px;
            z-index: 100;
            pointer-events: none;
        }
        
        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            bottom: 0;
            left: 0;
            pointer-events: auto;
            touch-action: none;
        }
        
        #joystickHandle {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        /* Action Buttons */
        #actionButtons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 200px;
            height: 200px;
            z-index: 100;
            pointer-events: none;
        }
        
        .action-btn {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: all 0.1s;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        .action-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.3);
        }
        
        #jumpBtn {
            top: 0;
            right: 0;
            background: rgba(76, 175, 80, 0.7);
            border-color: rgba(76, 175, 80, 0.9);
        }
        
        #glideBtn {
            bottom: 0;
            right: 40px;
            background: rgba(33, 150, 243, 0.7);
            border-color: rgba(33, 150, 243, 0.9);
        }
        
        #attackBtn {
            top: 40px;
            right: 0;
            background: rgba(244, 67, 54, 0.7);
            border-color: rgba(244, 67, 54, 0.9);
        }
        
        /* Glide Indicator */
        #glideIndicator {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 100px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }
        
        #glideBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #2196F3, #64B5F6);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.1s;
        }
        
        #glideText {
            position: absolute;
            top: 50px;
            right: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        /* Controls Hint */
        #controlsHint {
            position: absolute;
            bottom: 250px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            text-align: center;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        
        /* Mobile Detection */
        @media (min-width: 768px) {
            #joystickContainer, #actionButtons, #controlsHint {
                display: none;
            }
        }
        
        /* Desktop Controls Hint */
        .desktop-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        
        @media (max-width: 767px) {
            .desktop-hint {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="loading">Loading Game...</div>
    <div id="ui">
        <div>Move: WASD/Joystick | Jump: Space/Green Button | Glide: Shift/Blue Button</div>
        <div id="score">Score: 0 | Health: 100</div>
        <div id="position">Position: (0, 0, 0)</div>
        <div id="glideStatus">Glide: READY</div>
    </div>
    
    <!-- Joystick Controls -->
    <div id="joystickContainer">
        <div id="joystickBase">
            <div id="joystickHandle"></div>
        </div>
    </div>
    
    <!-- Action Buttons -->
    <div id="actionButtons">
        <div class="action-btn" id="jumpBtn">↑</div>
        <div class="action-btn" id="glideBtn">✈</div>
        <div class="action-btn" id="attackBtn">⚔</div>
    </div>
    
    <!-- Glide Indicator -->
    <div id="glideIndicator">
        <div id="glideBar"></div>
    </div>
    <div id="glideText">GLIDE</div>
    
    <!-- Controls Hint -->
    <div id="controlsHint">
        Touch joystick to move | Buttons for actions
    </div>
    
    <!-- Desktop Controls Hint -->
    <div class="desktop-hint">
        Desktop: WASD to move, Space to jump, Shift to glide
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==================== TOUCH/JOYSTICK CONTROLLER ====================
        class JoystickController {
            constructor() {
                this.base = document.getElementById('joystickBase');
                this.handle = document.getElementById('joystickHandle');
                this.active = false;
                this.maxDistance = 50;
                this.position = { x: 0, y: 0 };
                this.normalized = { x: 0, y: 0 };
                this.baseRect = this.base.getBoundingClientRect();
                this.centerX = this.baseRect.left + this.baseRect.width / 2;
                this.centerY = this.baseRect.top + this.baseRect.height / 2;
                
                this.init();
            }
            
            init() {
                // Mouse events
                this.base.addEventListener('mousedown', (e) => this.onStart(e.clientX, e.clientY));
                document.addEventListener('mousemove', (e) => this.onMove(e.clientX, e.clientY));
                document.addEventListener('mouseup', () => this.onEnd());
                
                // Touch events
                this.base.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.onStart(touch.clientX, touch.clientY);
                }, { passive: false });
                
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.onMove(touch.clientX, touch.clientY);
                }, { passive: false });
                
                document.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.onEnd();
                }, { passive: false });
                
                // Prevent context menu on joystick
                this.base.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            onStart(clientX, clientY) {
                this.active = true;
                this.baseRect = this.base.getBoundingClientRect();
                this.centerX = this.baseRect.left + this.baseRect.width / 2;
                this.centerY = this.baseRect.top + this.baseRect.height / 2;
                this.onMove(clientX, clientY);
            }
            
            onMove(clientX, clientY) {
                if (!this.active) return;
                
                let dx = clientX - this.centerX;
                let dy = clientY - this.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Limit to max distance
                if (distance > this.maxDistance) {
                    dx = (dx / distance) * this.maxDistance;
                    dy = (dy / distance) * this.maxDistance;
                }
                
                // Update handle position
                this.handle.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                // Update normalized values
                this.normalized.x = dx / this.maxDistance;
                this.normalized.y = -dy / this.maxDistance; // Invert Y for intuitive control
                
                // Update raw position
                this.position.x = dx;
                this.position.y = dy;
            }
            
            onEnd() {
                this.active = false;
                this.normalized.x = 0;
                this.normalized.y = 0;
                this.position.x = 0;
                this.position.y = 0;
                this.handle.style.transform = 'translate(-50%, -50%)';
            }
            
            getDirection() {
                return {
                    x: this.normalized.x,
                    y: this.normalized.y,
                    magnitude: Math.sqrt(this.normalized.x * this.normalized.x + this.normalized.y * this.normalized.y)
                };
            }
            
            isActive() {
                return this.active;
            }
        }

        // ==================== BUTTON CONTROLLER ====================
        class ButtonController {
            constructor() {
                this.buttons = {
                    jump: false,
                    glide: false,
                    attack: false
                };
                
                this.init();
            }
            
            init() {
                const jumpBtn = document.getElementById('jumpBtn');
                const glideBtn = document.getElementById('glideBtn');
                const attackBtn = document.getElementById('attackBtn');
                
                // Jump button
                this.setupButton(jumpBtn, 'jump');
                
                // Glide button
                this.setupButton(glideBtn, 'glide');
                
                // Attack button
                this.setupButton(attackBtn, 'attack');
                
                // Keyboard fallback
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (key === ' ') this.buttons.jump = true;
                    if (key === 'shift') this.buttons.glide = true;
                    if (key === 'e') this.buttons.attack = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (key === ' ') this.buttons.jump = false;
                    if (key === 'shift') this.buttons.glide = false;
                    if (key === 'e') this.buttons.attack = false;
                });
            }
            
            setupButton(element, buttonName) {
                // Mouse events
                element.addEventListener('mousedown', () => {
                    this.buttons[buttonName] = true;
                    element.style.transform = 'scale(0.85)';
                    element.style.opacity = '0.8';
                });
                
                element.addEventListener('mouseup', () => {
                    this.buttons[buttonName] = false;
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';
                });
                
                element.addEventListener('mouseleave', () => {
                    this.buttons[buttonName] = false;
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';
                });
                
                // Touch events
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.buttons[buttonName] = true;
                    element.style.transform = 'scale(0.85)';
                    element.style.opacity = '0.8';
                }, { passive: false });
                
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.buttons[buttonName] = false;
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';
                }, { passive: false });
                
                element.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.buttons[buttonName] = false;
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';
                }, { passive: false });
            }
            
            isPressed(buttonName) {
                return this.buttons[buttonName];
            }
            
            getAllButtons() {
                return { ...this.buttons };
            }
        }

        // ==================== SCENE SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 200);

        // ==================== CAMERA ====================
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 15);
        camera.lookAt(0, 0, 0);

        // ==================== RENDERER ====================
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // ==================== CONTROLS ====================
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.target.set(0, 3, 0);

        // ==================== LIGHTING ====================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 30, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 150;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.bias = -0.001;
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x3a3a3a, 0.4);
        scene.add(hemisphereLight);

        // ==================== CAPSULE GEOMETRY FIX ====================
        function createCapsuleGeometry(radius = 0.35, height = 1.4, radialSegments = 8, heightSegments = 16) {
            const geometry = new THREE.BufferGeometry();
            
            const vertices = [];
            const indices = [];
            const normals = [];
            const uvs = [];
            
            function addVertex(x, y, z, u, v) {
                vertices.push(x, y, z);
                const length = Math.sqrt(x * x + y * y + z * z);
                normals.push(x / length, y / length, z / length);
                uvs.push(u, v);
            }
            
            const topOffset = height / 2;
            for (let y = 0; y <= heightSegments / 2; y++) {
                const v = y / (heightSegments / 2);
                const theta = v * Math.PI / 2;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let x = 0; x <= radialSegments; x++) {
                    const u = x / radialSegments;
                    const phi = u * Math.PI * 2;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const px = radius * cosPhi * sinTheta;
                    const py = radius * cosTheta + topOffset;
                    const pz = radius * sinPhi * sinTheta;
                    
                    addVertex(px, py, pz, u, 1 - v * 0.5);
                }
            }
            
            const bottomOffset = -height / 2;
            const vertexOffset = (Math.floor(heightSegments / 2) + 1) * (radialSegments + 1);
            for (let y = 0; y <= heightSegments / 2; y++) {
                const v = y / (heightSegments / 2);
                const theta = Math.PI / 2 + v * Math.PI / 2;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let x = 0; x <= radialSegments; x++) {
                    const u = x / radialSegments;
                    const phi = u * Math.PI * 2;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const px = radius * cosPhi * sinTheta;
                    const py = radius * cosTheta + bottomOffset;
                    const pz = radius * sinPhi * sinTheta;
                    
                    addVertex(px, py, pz, u, 0.5 - v * 0.5);
                }
            }
            
            for (let y = 0; y < heightSegments / 2; y++) {
                for (let x = 0; x < radialSegments; x++) {
                    const a = y * (radialSegments + 1) + x;
                    const b = a + radialSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            for (let y = 0; y < heightSegments / 2; y++) {
                for (let x = 0; x < radialSegments; x++) {
                    const a = vertexOffset + y * (radialSegments + 1) + x;
                    const b = a + radialSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, c, b);
                    indices.push(b, c, d);
                }
            }
            
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            
            return geometry;
        }

        // ==================== PLAYER CLASS WITH GLIDE ====================
        class Player {
            constructor() {
                this.geometry = createCapsuleGeometry(0.35, 1.4, 8, 16);
                this.material = new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    roughness: 0.7,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.1
                });
                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.name = 'Player';
                
                // Physics properties
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.direction = new THREE.Vector3(0, 0, 0);
                this.speed = 6.0;
                this.jumpForce = 10.0;
                this.isOnGround = false;
                this.gravity = 9.8;
                this.friction = 0.9;
                this.airResistance = 0.98;
                
                // Glide properties
                this.isGliding = false;
                this.glideStamina = 100;
                this.maxGlideStamina = 100;
                this.glideStaminaRechargeRate = 20;
                this.glideStaminaDrainRate = 30;
                this.glideLift = 4.0;
                this.glideSpeedMultiplier = 1.5;
                this.glideControlMultiplier = 1.8;
                this.minGlideHeight = 2.0;
                this.glideCooldown = 0;
                
                // Player state
                this.health = 100;
                this.score = 0;
                this.isDoubleJumpAvailable = true;
                this.doubleJumpForce = 8.0;
                
                // Visual effects
                this.glideTrail = null;
                this.createGlideTrail();
                
                // Add player to scene
                scene.add(this.mesh);
                
                // Player collision box
                this.boundingSphere = new THREE.Sphere(this.mesh.position, 0.5);
            }
            
            createGlideTrail() {
                const trailGeometry = new THREE.BufferGeometry();
                const trailMaterial = new THREE.PointsMaterial({
                    color: 0x00ffff,
                    size: 0.2,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                this.glideTrail = new THREE.Points(trailGeometry, trailMaterial);
                this.glideTrail.visible = false;
                scene.add(this.glideTrail);
            }
            
            updateGlideTrail(deltaTime) {
                if (!this.isGliding || this.glideStamina <= 0) {
                    this.glideTrail.visible = false;
                    return;
                }
                
                this.glideTrail.visible = true;
                
                // Add new trail point
                const position = this.mesh.position.clone();
                
                // Update trail geometry
                let positions = this.glideTrail.geometry.attributes.position;
                let count = positions ? positions.count : 0;
                
                if (!positions || count >= 50) {
                    // Create new buffer with current position
                    const newPositions = new Float32Array(3);
                    newPositions[0] = position.x;
                    newPositions[1] = position.y;
                    newPositions[2] = position.z;
                    
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
                    this.glideTrail.geometry = geometry;
                } else {
                    // Add to existing buffer
                    const newCount = count + 1;
                    const newPositions = new Float32Array(newCount * 3);
                    
                    if (count > 0) {
                        const oldArray = positions.array;
                        for (let i = 0; i < oldArray.length; i++) {
                            newPositions[i] = oldArray[i];
                        }
                    }
                    
                    newPositions[newCount * 3 - 3] = position.x;
                    newPositions[newCount * 3 - 2] = position.y;
                    newPositions[newCount * 3 - 1] = position.z;
                    
                    this.glideTrail.geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
                }
                
                // Fade trail points
                const positionsAttr = this.glideTrail.geometry.attributes.position;
                if (positionsAttr && positionsAttr.count > 1) {
                    const positionsArray = positionsAttr.array;
                    for (let i = 0; i < positionsArray.length - 3; i++) {
                        positionsArray[i] += (positionsArray[i + 3] - positionsArray[i]) * 0.1;
                    }
                    positionsAttr.needsUpdate = true;
                }
            }
            
            startGlide() {
                if (this.glideStamina > 10 && !this.isOnGround && this.glideCooldown <= 0) {
                    this.isGliding = true;
                    console.log("Started gliding!");
                    return true;
                }
                return false;
            }
            
            stopGlide() {
                if (this.isGliding) {
                    this.isGliding = false;
                    this.glideCooldown = 0.5;
                    console.log("Stopped gliding");
                    this.glideTrail.visible = false;
                    return true;
                }
                return false;
            }
            
            updateGlide(deltaTime) {
                // Update cooldown
                if (this.glideCooldown > 0) {
                    this.glideCooldown -= deltaTime;
                }
                
                if (this.isGliding) {
                    // Drain stamina
                    this.glideStamina -= this.glideStaminaDrainRate * deltaTime;
                    
                    if (this.glideStamina <= 0) {
                        this.glideStamina = 0;
                        this.stopGlide();
                        return;
                    }
                    
                    // Apply glide physics
                    if (this.velocity.y < 0) {
                        // Reduce fall speed
                        this.velocity.y = Math.max(this.velocity.y, -this.glideLift);
                        
                        // Add forward momentum if moving
                        if (this.direction.length() > 0.1) {
                            const glideBoost = this.direction.clone().multiplyScalar(this.speed * this.glideSpeedMultiplier * deltaTime);
                            this.velocity.x += glideBoost.x;
                            this.velocity.z += glideBoost.z;
                        }
                        
                        // Better air control while gliding
                        this.velocity.x *= 0.99;
                        this.velocity.z *= 0.99;
                    }
                    
                    // Update visual effects
                    this.updateGlideTrail(deltaTime);
                    
                    // Update player material for visual feedback
                    this.mesh.material.emissive.setHex(0x00ffff);
                    this.mesh.material.emissiveIntensity = 0.3;
                    
                } else {
                    // Recharge stamina
                    if (this.glideStamina < this.maxGlideStamina) {
                        this.glideStamina += this.glideStaminaRechargeRate * deltaTime;
                        if (this.glideStamina > this.maxGlideStamina) {
                            this.glideStamina = this.maxGlideStamina;
                        }
                    }
                    
                    // Reset visual effects
                    this.mesh.material.emissive.setHex(0x003300);
                    this.mesh.material.emissiveIntensity = 0.1;
                }
                
                // Update glide indicator
                this.updateGlideIndicator();
            }
            
            updateGlideIndicator() {
                const glideBar = document.getElementById('glideBar');
                const glideText = document.getElementById('glideText');
                const glideStatus = document.getElementById('glideStatus');
                
                if (glideBar) {
                    const scale = this.glideStamina / this.maxGlideStamina;
                    glideBar.style.transform = `scaleX(${scale})`;
                    
                    if (this.isGliding) {
                        glideBar.style.background = 'linear-gradient(90deg, #FF5722, #FF9800)';
                        glideText.textContent = 'GLIDING';
                        glideText.style.color = '#FF9800';
                        if (glideStatus) glideStatus.textContent = `Glide: ${Math.round(this.glideStamina)}%`;
                    } else {
                        glideBar.style.background = 'linear-gradient(90deg, #2196F3, #64B5F6)';
                        glideText.textContent = 'GLIDE';
                        glideText.style.color = '#64B5F6';
                        if (glideStatus) glideStatus.textContent = `Glide: ${Math.round(this.glideStamina)}%`;
                    }
                }
            }
            
            update(deltaTime) {
                // Update glide
                this.updateGlide(deltaTime);
                
                // Apply gravity if not gliding or on ground
                if (!this.isGliding && !this.isOnGround) {
                    this.velocity.y -= this.gravity * deltaTime;
                }
                
                // Apply friction/air resistance
                if (this.isOnGround) {
                    this.velocity.x *= this.friction;
                    this.velocity.z *= this.friction;
                } else if (!this.isGliding) {
                    this.velocity.x *= this.airResistance;
                    this.velocity.z *= this.airResistance;
                }
                
                // Update position
                this.mesh.position.x += this.velocity.x * deltaTime;
                this.mesh.position.y += this.velocity.y * deltaTime;
                this.mesh.position.z += this.velocity.z * deltaTime;
                
                // Update bounding sphere
                this.boundingSphere.center.copy(this.mesh.position);
                
                // Ground collision
                if (this.mesh.position.y < 0) {
                    this.mesh.position.y = 0;
                    this.velocity.y = 0;
                    this.isOnGround = true;
                    this.isDoubleJumpAvailable = true;
                    if (this.isGliding) this.stopGlide();
                }
                
                // Boundary constraints
                const boundary = 45;
                this.mesh.position.x = Math.max(-boundary, Math.min(boundary, this.mesh.position.x));
                this.mesh.position.z = Math.max(-boundary, Math.min(boundary, this.mesh.position.z));
                
                // Rotate player based on movement
                if (this.velocity.x !== 0 || this.velocity.z !== 0) {
                    const angle = Math.atan2(this.velocity.x, this.velocity.z);
                    this.mesh.rotation.y = angle;
                }
                
                // Tilt while gliding
                if (this.isGliding) {
                    const tiltX = Math.sin(Date.now() * 0.005) * 0.1;
                    const tiltZ = Math.cos(Date.now() * 0.005) * 0.1;
                    this.mesh.rotation.x = tiltX;
                    this.mesh.rotation.z = tiltZ;
                } else {
                    this.mesh.rotation.x = 0;
                    this.mesh.rotation.z = 0;
                }
            }
            
            move(forward, right) {
                this.direction.set(right, 0, -forward).normalize();
                
                // Calculate speed multiplier
                let speedMultiplier = this.speed;
                let controlMultiplier = 1.0;
                
                if (this.isGliding) {
                    speedMultiplier *= this.glideSpeedMultiplier;
                    controlMultiplier = this.glideControlMultiplier;
                } else if (!this.isOnGround) {
                    speedMultiplier *= 0.5;
                    controlMultiplier = 0.7;
                }
                
                // Apply movement
                if (this.isOnGround) {
                    this.velocity.x = this.direction.x * speedMultiplier;
                    this.velocity.z = this.direction.z * speedMultiplier;
                } else {
                    // Air control
                    this.velocity.x += this.direction.x * speedMultiplier * deltaTime * controlMultiplier;
                    this.velocity.z += this.direction.z * speedMultiplier * deltaTime * controlMultiplier;
                    
                    // Limit horizontal speed
                    const horizontalSpeed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);
                    const maxSpeed = this.isGliding ? this.speed * 2 : this.speed * 0.8;
                    if (horizontalSpeed > maxSpeed) {
                        const scale = maxSpeed / horizontalSpeed;
                        this.velocity.x *= scale;
                        this.velocity.z *= scale;
                    }
                }
            }
            
            jump() {
                if (this.isOnGround) {
                    this.velocity.y = this.jumpForce;
                    this.isOnGround = false;
                    console.log("Jumped!");
                    return true;
                } else if (this.isDoubleJumpAvailable) {
                    this.velocity.y = this.doubleJumpForce;
                    this.isDoubleJumpAvailable = false;
                    console.log("Double jumped!");
                    return true;
                }
                return false;
            }
            
            stop() {
                if (this.isOnGround) {
                    this.velocity.x = 0;
                    this.velocity.z = 0;
                }
            }
            
            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                return this.health > 0;
            }
            
            addScore(points) {
                this.score += points;
                return this.score;
            }
            
            getPosition() {
                return this.mesh.position.clone();
            }
            
            reset() {
                this.mesh.position.set(0, 5, 0);
                this.velocity.set(0, 0, 0);
                this.health = 100;
                this.isOnGround = false;
                this.isDoubleJumpAvailable = true;
                this.stopGlide();
                this.glideStamina = this.maxGlideStamina;
                this.glideCooldown = 0;
            }
        }

        // ==================== GAME MANAGER ====================
        class Game {
            constructor() {
                // Initialize controllers
                this.joystick = new JoystickController();
                this.buttons = new ButtonController();
                
                // Initialize player and game state
                this.player = new Player();
                this.keys = {};
                this.clock = new THREE.Clock();
                this.platforms = [];
                this.collectibles = [];
                this.obstacles = [];
                this.gameTime = 0;
                this.isPaused = false;
                this.gameOver = false;
                
                // Initialize game
                this.init();
                this.setupEventListeners();
                this.hideLoadingScreen();
                this.animate();
            }
            
            init() {
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x808080,
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                ground.name = 'Ground';
                scene.add(ground);
                
                // Add texture variation
                const groundColors = [0x808080, 0x707070, 0x909090];
                const groundVertices = groundGeometry.attributes.position;
                const groundColorsAttr = new Float32Array(groundVertices.count * 3);
                
                for (let i = 0; i < groundVertices.count; i++) {
                    const x = groundVertices.getX(i);
                    const z = groundVertices.getY(i);
                    const colorIndex = Math.floor((x + z) * 2) % groundColors.length;
                    const color = new THREE.Color(groundColors[colorIndex]);
                    
                    groundColorsAttr[i * 3] = color.r;
                    groundColorsAttr[i * 3 + 1] = color.g;
                    groundColorsAttr[i * 3 + 2] = color.b;
                }
                
                groundGeometry.setAttribute('color', new THREE.BufferAttribute(groundColorsAttr, 3));
                groundMaterial.vertexColors = true;
                
                // Platforms for gliding
                const platformGeometry = new THREE.BoxGeometry(8, 0.5, 8);
                const platformMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a90e2,
                    roughness: 0.6,
                    metalness: 0.3
                });
                
                // Create high platforms for gliding
                const platformPositions = [
                    { x: -20, y: 15, z: -10 },
                    { x: 20, y: 20, z: 5 },
                    { x: 0, y: 25, z: 20 },
                    { x: -15, y: 18, z: 25 },
                    { x: 15, y: 22, z: -15 },
                    { x: -25, y: 12, z: 0 },
                    { x: 25, y: 16, z: 15 },
                    { x: -10, y: 28, z: -20 }
                ];
                
                for (let i = 0; i < platformPositions.length; i++) {
                    const pos = platformPositions[i];
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.position.set(pos.x, pos.y, pos.z);
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    platform.name = `Platform_${i}`;
                    
                    scene.add(platform);
                    this.platforms.push({
                        mesh: platform,
                        boundingBox: new THREE.Box3().setFromObject(platform)
                    });
                }
                
                // Gliding rings (collectibles)
                const ringGeometry = new THREE.TorusGeometry(2, 0.3, 8, 24);
                const ringMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x0088ff,
                    emissiveIntensity: 0.5,
                    roughness: 0.3,
                    metalness: 0.8
                });
                
                // Create rings in the air for gliding through
                for (let i = 0; i < 20; i++) {
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    // Place rings between platforms
                    const startPlatform = this.platforms[Math.floor(Math.random() * this.platforms.length)];
                    const endPlatform = this.platforms[Math.floor(Math.random() * this.platforms.length)];
                    
                    const t = Math.random();
                    const x = startPlatform.mesh.position.x * (1-t) + endPlatform.mesh.position.x * t;
                    const y = (startPlatform.mesh.position.y + endPlatform.mesh.position.y) / 2 + Math.random() * 5;
                    const z = startPlatform.mesh.position.z * (1-t) + endPlatform.mesh.position.z * t;
                    
                    ring.position.set(x, y, z);
                    ring.castShadow = true;
                    ring.name = `Ring_${i}`;
                    
                    // Animation properties
                    ring.userData.rotationSpeed = 2;
                    ring.userData.floatSpeed = 1;
                    ring.userData.floatHeight = 0.5;
                    ring.userData.floatOffset = Math.random() * Math.PI * 2;
                    ring.userData.collected = false;
                    
                    scene.add(ring);
                    this.collectibles.push(ring);
                }
                
                // Skybox
                const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                const skyMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                scene.add(sky);
                
                // Clouds for atmosphere
                const cloudGeometry = new THREE.SphereGeometry(3, 8, 8);
                const cloudMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7,
                    roughness: 1.0
                });
                
                for (let i = 0; i < 15; i++) {
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloud.position.set(
                        (Math.random() - 0.5) * 200,
                        30 + Math.random() * 20,
                        (Math.random() - 0.5) * 200
                    );
                    cloud.scale.set(
                        1 + Math.random() * 2,
                        0.5 + Math.random() * 0.5,
                        1 + Math.random() * 2
                    );
                    scene.add(cloud);
                }
            }
            
            hideLoadingScreen() {
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
            }
            
            setupEventListeners() {
                // Keyboard input for desktop
                window.addEventListener('keydown', (event) => {
                    const key = event.key.toLowerCase();
                    this.keys[key] = true;
                    
                    if (key === ' ') {
                        event.preventDefault();
                        this.player.jump();
                    }
                    
                    if (key === 'shift') {
                        this.player.startGlide();
                    }
                    
                    if (key === 'escape') {
                        this.isPaused = !this.isPaused;
                        console.log('Game', this.isPaused ? 'paused' : 'resumed');
                    }
                    
                    if (key === 'r') {
                        this.resetGame();
                    }
                });
                
                window.addEventListener('keyup', (event) => {
                    const key = event.key.toLowerCase();
                    this.keys[key] = false;
                    
                    if (key === 'shift') {
                        this.player.stopGlide();
                    }
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Prevent right-click menu
                renderer.domElement.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
            }
            
            handleInput(deltaTime) {
                if (this.isPaused || this.gameOver) return;
                
                let forward = 0;
                let right = 0;
                
                // Check joystick input
                const joystickDir = this.joystick.getDirection();
                if (joystickDir.magnitude > 0.1) {
                    forward = joystickDir.y;
                    right = joystickDir.x;
                } else {
                    // Check keyboard input
                    if (this.keys['w'] || this.keys['arrowup']) forward += 1;
                    if (this.keys['s'] || this.keys['arrowdown']) forward -= 1;
                    if (this.keys['a'] || this.keys['arrowleft']) right -= 1;
                    if (this.keys['d'] || this.keys['arrowright']) right += 1;
                }
                
                // Check button input for glide
                if (this.buttons.isPressed('glide')) {
                    this.player.startGlide();
                } else if (this.player.isGliding && !this.keys['shift']) {
                    this.player.stopGlide();
                }
                
                // Check button input for jump
                if (this.buttons.isPressed('jump')) {
                    this.player.jump();
                }
                
                // Move player if any input
                if (forward !== 0 || right !== 0) {
                    this.player.move(forward, right);
                } else {
                    this.player.stop();
                }
            }
            
            checkCollisions() {
                const playerPos = this.player.getPosition();
                const playerSphere = this.player.boundingSphere;
                
                // Platform collisions
                for (const platform of this.platforms) {
                    const platformBox = platform.boundingBox;
                    
                    if (playerPos.y >= platform.mesh.position.y - 1 && 
                        playerPos.y <= platform.mesh.position.y + 2) {
                        
                        const platformCenter = new THREE.Vector3();
                        platformBox.getCenter(platformCenter);
                        
                        const distanceX = Math.abs(playerPos.x - platformCenter.x);
                        const distanceZ = Math.abs(playerPos.z - platformCenter.z);
                        
                        if (distanceX < 4 && distanceZ < 4) {
                            if (playerPos.y < platform.mesh.position.y + 0.5) {
                                playerPos.y = platform.mesh.position.y + 0.5;
                                this.player.mesh.position.y = playerPos.y;
                                this.player.velocity.y = 0;
                                this.player.isOnGround = true;
                                this.player.isDoubleJumpAvailable = true;
                            }
                        }
                    }
                }
                
                // Ring collection
                for (let i = this.collectibles.length - 1; i >= 0; i--) {
                    const ring = this.collectibles[i];
                    
                    if (ring.userData.collected) continue;
                    
                    const distance = playerPos.distanceTo(ring.position);
                    
                    if (distance < 2.5) {
                        ring.userData.collected = true;
                        this.player.addScore(50);
                        
                        // Bonus for collecting while gliding
                        if (this.player.isGliding) {
                            this.player.addScore(25);
                            this.player.glideStamina = Math.min(this.player.maxGlideStamina, this.player.glideStamina + 20);
                            console.log("Bonus! Collected while gliding!");
                        }
                        
                        // Visual effect
                        ring.material.emissiveIntensity = 2.0;
                        ring.material.opacity = 0.5;
                        ring.material.transparent = true;
                        
                        // Remove after animation
                        setTimeout(() => {
                            scene.remove(ring);
                            this.collectibles.splice(i, 1);
                        }, 300);
                        
                        console.log('Collected ring! Score:', this.player.score);
                    }
                }
                
                // Boundary check
                if (playerPos.y < -10) {
                    this.player.takeDamage(10);
                    this.player.reset();
                    console.log('Player fell! Health:', this.player.health);
                }
                
                // Game over check
                if (this.player.health <= 0 && !this.gameOver) {
                    this.gameOver = true;
                    console.log('GAME OVER! Final Score:', this.player.score);
                    alert(`Game Over! Your score: ${this.player.score}`);
                }
            }
            
            updateCollectibles(deltaTime) {
                for (const ring of this.collectibles) {
                    if (ring.userData.collected) continue;
                    
                    // Floating animation
                    const floatTime = this.gameTime * ring.userData.floatSpeed + ring.userData.floatOffset;
                    ring.position.y += Math.sin(floatTime) * 0.01;
                    
                    // Rotation animation
                    ring.rotation.y += ring.userData.rotationSpeed * deltaTime;
                    ring.rotation.x = Math.sin(floatTime * 0.5) * 0.2;
                }
            }
            
            updateUI() {
                const scoreElement = document.getElementById('score');
                const positionElement = document.getElementById('position');
                
                if (scoreElement) {
                    scoreElement.textContent = `Score: ${this.player.score} | Health: ${this.player.health}`;
                }
                
                if (positionElement) {
                    const pos = this.player.getPosition();
                    positionElement.textContent = `Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`;
                }
            }
            
            resetGame() {
                this.player.reset();
                this.player.score = 0;
                this.player.health = 100;
                
                for (const ring of this.collectibles) {
                    scene.remove(ring);
                }
                this.collectibles = [];
                
                this.gameOver = false;
                this.isPaused = false;
                this.gameTime = 0;
                
                console.log('Game reset!');
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.isPaused) return;
                
                const deltaTime = Math.min(this.clock.getDelta(), 0.1);
                this.gameTime += deltaTime;
                
                // Handle input
                this.handleInput(deltaTime);
                
                // Update player
                this.player.update(deltaTime);
                
                // Update animations
                this.updateCollectibles(deltaTime);
                
                // Check collisions
                this.checkCollisions();
                
                // Update UI
                this.updateUI();
                
                // Update controls
                controls.update();
                
                // Render scene
                renderer.render(scene, camera);
            }
        }

        // ==================== INITIALIZE GAME ====================
        window.addEventListener('load', () => {
            try {
                console.log('Initializing game with joystick controls...');
                
                // Create and start the game
                const game = new Game();
                
                // Make accessible for debugging
                window.game = game;
                
                console.log('Game loaded successfully!');
                console.log('Desktop: WASD to move, Space to jump, Shift to glide');
                console.log('Mobile: Use joystick and buttons');
                
            } catch (error) {
                console.error('Game initialization error:', error);
                
                const errorMessage = document.createElement('div');
                errorMessage.style.position = 'absolute';
                errorMessage.style.top = '50%';
                errorMessage.style.left = '50%';
                errorMessage.style.transform = 'translate(-50%, -50%)';
                errorMessage.style.color = 'red';
                errorMessage.style.fontSize = '20px';
                errorMessage.style.backgroundColor = 'rgba(0,0,0,0.8)';
                errorMessage.style.padding = '20px';
                errorMessage.style.borderRadius = '10px';
                errorMessage.style.textAlign = 'center';
                errorMessage.innerHTML = `
                    <h2>Game Failed to Load</h2>
                    <p>${error.message}</p>
                    <p>Please check the browser console for details.</p>
                `;
                document.body.appendChild(errorMessage);
                
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
            }
        });

        // ==================== ERROR HANDLING ====================
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            event.preventDefault();
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            event.preventDefault();
        });

    </script>
</body>
</html>
