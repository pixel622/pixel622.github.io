<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SURVIVING ¬∑ lone car ¬∑ slow dead</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Courier New', Courier, monospace;
        }
        body {
            margin: 0;
            min-height: 100vh;
            background: #0a0f0e;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;  /* prevent pull-to-refresh */
        }
        .game-container {
            background: #1a2a1f;
            border-radius: 2rem;
            padding: 1rem;
            box-shadow: 0 20px 30px rgba(0,0,0,0.8);
            border: 3px solid #5f7a5f;
        }
        canvas {
            display: block;
            margin: 0 auto;
            width: 100%;
            height: auto;
            border-radius: 1.5rem;
            background: #2a3f2a;
            box-shadow: inset 0 0 20px #0f1a0f;
            cursor: none;
            touch-action: none;
        }
        /* status bar */
        .stats {
            display: flex;
            justify-content: space-between;
            color: #b5d6b0;
            text-shadow: 2px 2px 0 #1f3a1f;
            font-weight: bold;
            font-size: 1.2rem;
            margin: 0.5rem 0.2rem 1rem 0.2rem;
            padding: 0 0.5rem;
        }
        .stats span {
            background: #1f2e1f;
            padding: 0.3rem 1rem;
            border-radius: 3rem;
            border: 1px solid #6f9a6f;
            box-shadow: inset 0 2px 3px #0f1f0f;
        }
        /* mobile controls */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1.2rem;
            padding: 0 0.5rem;
            gap: 1rem;
        }
        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 0.5rem;
            width: 10rem;
            height: 10rem;
            filter: drop-shadow(0 8px 4px #0f1a0f);
        }
        .dpad-btn {
            background: #364d36;
            border: 3px solid #718e71;
            border-radius: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            color: #d9eed9;
            text-shadow: 2px 2px 0 #1f3a1f;
            box-shadow: 0 5px 0 #1f321f, 0 8px 8px rgba(0,0,0,0.6);
            transition: all 0.04s ease;
            touch-action: manipulation;
            cursor: pointer;
        }
        .dpad-btn:active {
            transform: translateY(5px);
            box-shadow: 0 2px 0 #1f321f, 0 5px 8px rgba(0,0,0,0.6);
            background: #2f422f;
        }
        .empty {
            visibility: hidden;
        }
        .attack-btn {
            background: #6d3f3f;
            border: 4px solid #b18080;
            width: 7rem;
            height: 7rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffd9d9;
            text-shadow: 2px 2px 0 #4f2f2f;
            box-shadow: 0 6px 0 #3f2a2a, 0 10px 15px rgba(0,0,0,0.6);
            touch-action: manipulation;
            cursor: pointer;
        }
        .attack-btn:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #3f2a2a, 0 8px 12px rgba(0,0,0,0.6);
            background: #5a3434;
        }
        /* desktop hint */
        .desktop-hint {
            color: #6d8f6d;
            text-align: center;
            margin-top: 0.8rem;
            font-size: 0.9rem;
        }
        .reset-btn {
            background: #4f624f;
            border: 2px solid #8fae8f;
            color: #eaffea;
            font-weight: bold;
            font-size: 1.1rem;
            padding: 0.3rem 1.2rem;
            border-radius: 2rem;
            cursor: pointer;
            box-shadow: 0 4px 0 #2f402f;
            transition: 0.05s linear;
            touch-action: manipulation;
        }
        .reset-btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }
        .status-message {
            color: #f7c9a3;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            margin-top: 0.4rem;
            background: #1f2e1fcc;
            border-radius: 3rem;
            padding: 0.2rem 0;
        }
    </style>
</head>
<body>
<div>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="stats">
            <span>‚ù§Ô∏è <span id="healthDisplay">100</span>%</span>
            <span>‚õΩ <span id="fuelDisplay">0</span>/100</span>
            <span>üßü <span id="zombieCount">0</span></span>
        </div>

        <!-- mobile friendly controls -->
        <div class="controls">
            <!-- direction pad (4 directions + blank) -->
            <div class="dpad">
                <div></div> <!-- empty top-left -->
                <div class="dpad-btn" id="upBtn">‚ñ≤</div>
                <div></div>
                <div class="dpad-btn" id="leftBtn">‚óÄ</div>
                <div class="empty"></div> <!-- center empty -->
                <div class="dpad-btn" id="rightBtn">‚ñ∂</div>
                <div></div>
                <div class="dpad-btn" id="downBtn">‚ñº</div>
                <div></div>
            </div>

            <!-- attack button (big) -->
            <div class="attack-btn" id="attackBtn">‚öîÔ∏è</div>
        </div>

        <!-- extra info & reset -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.7rem;">
            <div class="desktop-hint">‚Üê‚Üë‚Üì‚Üí / A</div>
            <div class="reset-btn" id="resetBtn">‚Üª RESTART</div>
        </div>
        <div id="messageArea" class="status-message">Find 5 fuel cans for the car...</div>
    </div>
</div>

<script>
    (function() {
        // ---------- CANVAS ----------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // display elements
        const healthSpan = document.getElementById('healthDisplay');
        const fuelSpan = document.getElementById('fuelDisplay');
        const zombieSpan = document.getElementById('zombieCount');
        const messageDiv = document.getElementById('messageArea');

        // ---------- FIXED DIMENSIONS ----------
        const W = 800, H = 600;
        canvas.width = W; canvas.height = H;

        // ---------- GAME STATE ----------
        let gameActive = true;
        let gameWin = false;
        let gameOver = false;

        // player
        let player = {
            x: 400, y: 300,
            r: 18,
            health: 100,
            maxHealth: 100,
            speed: 3.5
        };

        // car (static) ‚Äì broken down, needs fuel
        const car = {
            x: 680, y: 120,
            r: 28,
            fuel: 0,         // collected fuel
            maxFuel: 100     // 5 cans * 20
        };

        // fuel cans (each gives +20 when brought to car)
        let fuelCans = [];
        const FUEL_VALUE = 20;
        const CANS_NEEDED = 5;  // 5 * 20 = 100
        // generate starting cans
        function generateFuelCans() {
            fuelCans = [];
            for (let i = 0; i < CANS_NEEDED; i++) {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 500) {
                    let x = 50 + Math.random() * 700;
                    let y = 50 + Math.random() * 500;
                    // not too close to car or player start
                    let distToCar = Math.hypot(x - car.x, y - car.y);
                    let distToPlayer = Math.hypot(x - player.x, y - player.y);
                    if (distToCar > 100 && distToPlayer > 100) {
                        fuelCans.push({ x, y, r: 10, collected: false });
                        placed = true;
                    }
                    attempts++;
                }
                // fallback
                if (!placed) fuelCans.push({ x: 100 + i*50, y: 400 + i*30, r:10, collected: false });
            }
        }

        // zombies array
        let zombies = [];
        const ZOMBIE_SPEED = 0.8;      // slow but steady
        const ZOMBIE_R = 16;
        const PLAYER_ATTACK_RANGE = 45; // melee distance
        const ZOMBIE_ATTACK_COOLDOWN = 40; // frames
        let globalAttackCooldown = 0;   // simple cooldown for attack button

        // spawning
        let spawnTimer = 0;
        const SPAWN_DELAY = 120; // frames ~2 seconds at 60fps

        // movement flags for keyboard & dpad
        let moveUp = false, moveDown = false, moveLeft = false, moveRight = false;

        // ---------- HELPER FUNCTIONS ----------
        function updateUI() {
            healthSpan.innerText = Math.max(0, player.health);
            fuelSpan.innerText = car.fuel;
            zombieSpan.innerText = zombies.length;
        }

        function resetGame() {
            gameActive = true;
            gameWin = false;
            gameOver = false;
            player = { x: 400, y: 300, r: 18, health: 100, maxHealth: 100, speed: 3.5 };
            car.fuel = 0;
            zombies = [];
            spawnTimer = 0;
            globalAttackCooldown = 0;
            generateFuelCans();
            updateUI();
            messageDiv.innerText = "Find 5 fuel cans for the car...";
        }

        // check win condition
        function checkWin() {
            if (car.fuel >= car.maxFuel && gameActive && !gameWin) {
                gameWin = true;
                gameActive = false;
                messageDiv.innerText = "‚ú® CAR FIXED! YOU DRIVE AWAY... VICTORY ‚ú®";
            }
        }

        // attack mechanic
        function attackZombies() {
            if (!gameActive || gameWin || gameOver) return;
            if (globalAttackCooldown > 0) return;

            let killedAny = false;
            for (let i = zombies.length - 1; i >= 0; i--) {
                const z = zombies[i];
                const dist = Math.hypot(player.x - z.x, player.y - z.y);
                if (dist < PLAYER_ATTACK_RANGE) {
                    zombies.splice(i, 1);
                    killedAny = true;
                }
            }
            if (killedAny) {
                globalAttackCooldown = 15;  // short cooldown (0.25s)
            }
            updateUI();
        }

        // collision between player and zombies -> damage
        function handleZombieCollisions() {
            if (!gameActive || gameWin || gameOver) return;
            for (let z of zombies) {
                const dist = Math.hypot(player.x - z.x, player.y - z.y);
                if (dist < player.r + z.r) {
                    // push player away lightly
                    const angle = Math.atan2(player.y - z.y, player.x - z.x);
                    player.x += Math.cos(angle) * 12;
                    player.y += Math.sin(angle) * 12;
                    // clamp to map
                    player.x = Math.max(player.r, Math.min(W - player.r, player.x));
                    player.y = Math.max(player.r, Math.min(H - player.r, player.y));

                    player.health -= 8;
                    if (player.health <= 0) {
                        player.health = 0;
                        gameActive = false;
                        gameOver = true;
                        messageDiv.innerText = "‚ò†Ô∏è YOU DIED... GAME OVER ‚ò†Ô∏è";
                    }
                    updateUI();
                    break; // only one hit per frame
                }
            }
        }

        // collect fuel (if player touches can, mark as collected, add fuel only when near car? we decide: must bring to car)
        // simpler: if player touches a can, it sticks to player? no, we want deposit at car.
        // approach: fuel cans are objects. When player collides with a can, we pick it up (can.collected = true) and increment a carried counter? 
        // But we want "bring to car" mechanic. Let's do: when player touches a can, can is removed from map, and a "pending fuel" count increments.
        // Then when player touches car, pending fuel is added to car.fuel (if car not full).
        // That feels intuitive: you carry fuel in your hands, but you must go back to car.
        let carriedFuel = 0; // amount collected but not yet deposited

        function handleItemCollection() {
            if (!gameActive || gameWin || gameOver) return;
            for (let i = fuelCans.length - 1; i >= 0; i--) {
                const can = fuelCans[i];
                if (can.collected) continue; // already removed
                const dist = Math.hypot(player.x - can.x, player.y - can.y);
                if (dist < player.r + can.r) {
                    // pick up fuel can
                    fuelCans.splice(i, 1);
                    carriedFuel += FUEL_VALUE;
                    messageDiv.innerText = `‚õΩ Fuel collected! Return to car (${carriedFuel}/100)`;
                }
            }
        }

        function depositFuelAtCar() {
            if (!gameActive || gameWin || gameOver) return;
            if (carriedFuel <= 0) return;
            const distToCar = Math.hypot(player.x - car.x, player.y - car.y);
            if (distToCar < player.r + car.r) {
                let fuelNeeded = car.maxFuel - car.fuel;
                let fuelToAdd = Math.min(carriedFuel, fuelNeeded);
                car.fuel += fuelToAdd;
                carriedFuel -= fuelToAdd;
                messageDiv.innerText = `‚õΩ Fuel deposited. Total: ${car.fuel}/${car.maxFuel}`;
                checkWin();
                updateUI();
            }
        }

        // move player based on flags
        function movePlayer() {
            if (!gameActive || gameWin || gameOver) return;
            let dx = 0, dy = 0;
            if (moveLeft) dx -= 1;
            if (moveRight) dx += 1;
            if (moveUp) dy -= 1;
            if (moveDown) dy += 1;

            if (dx !== 0 || dy !== 0) {
                const len = Math.hypot(dx, dy);
                dx = dx / len * player.speed;
                dy = dy / len * player.speed;
                let newX = player.x + dx;
                let newY = player.y + dy;

                // boundary
                newX = Math.max(player.r, Math.min(W - player.r, newX));
                newY = Math.max(player.r, Math.min(H - player.r, newY));

                player.x = newX;
                player.y = newY;
            }
        }

        // zombie AI: move towards player
        function moveZombies() {
            for (let z of zombies) {
                const dx = player.x - z.x;
                const dy = player.y - z.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0.5) {
                    const moveX = (dx / dist) * ZOMBIE_SPEED;
                    const moveY = (dy / dist) * ZOMBIE_SPEED;
                    z.x += moveX;
                    z.y += moveY;
                }
                // keep zombies inside canvas (optional)
                z.x = Math.max(ZOMBIE_R, Math.min(W - ZOMBIE_R, z.x));
                z.y = Math.max(ZOMBIE_R, Math.min(H - ZOMBIE_R, z.y));
            }
        }

        // spawn zombies at edges
        function spawnZombie() {
            if (!gameActive || gameWin || gameOver) return;
            const side = Math.floor(Math.random() * 4);
            let x, y;
            const pad = 30;
            if (side === 0) { // top
                x = Math.random() * W;
                y = -pad;
            } else if (side === 1) { // right
                x = W + pad;
                y = Math.random() * H;
            } else if (side === 2) { // bottom
                x = Math.random() * W;
                y = H + pad;
            } else { // left
                x = -pad;
                y = Math.random() * H;
            }
            zombies.push({ x, y, r: ZOMBIE_R });
        }

        // drawing
        function draw() {
            ctx.clearRect(0, 0, W, H);

            // background ground (rough)
            ctx.fillStyle = '#3d5a3d';
            ctx.fillRect(0, 0, W, H);
            // grid / foliage pattern
            ctx.strokeStyle = '#4f734f';
            ctx.lineWidth = 1;
            for (let i = 0; i < W; i += 50) {
                ctx.beginPath();
                ctx.strokeStyle = '#3a553a';
                ctx.moveTo(i, 0);
                ctx.lineTo(i, H);
                ctx.stroke();
            }
            for (let i = 0; i < H; i += 50) {
                ctx.beginPath();
                ctx.strokeStyle = '#3a553a';
                ctx.moveTo(0, i);
                ctx.lineTo(W, i);
                ctx.stroke();
            }

            // CAR (broken but hopeful)
            ctx.fillStyle = '#4b6b8f';
            ctx.shadowColor = '#0f1f1f';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(car.x, car.y, car.r, 0, 2*Math.PI);
            ctx.fill();
            ctx.fillStyle = '#2a4055';
            ctx.beginPath();
            ctx.arc(car.x-6, car.y-6, 8, 0, 2*Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(car.x+10, car.y+2, 8, 0, 2*Math.PI);
            ctx.fill();
            ctx.fillStyle = '#dbb47a';
            ctx.font = 'bold 20px monospace';
            ctx.fillText('üöô', car.x-20, car.y+8);
            ctx.shadowBlur = 0;

            // fuel cans (only those not collected)
            ctx.fillStyle = '#d1b45a';
            ctx.shadowBlur = 8;
            fuelCans.forEach(can => {
                ctx.beginPath();
                ctx.arc(can.x, can.y, can.r, 0, 2*Math.PI);
                ctx.fill();
                ctx.fillStyle = '#ad822b';
                ctx.font = '16px monospace';
                ctx.fillText('‚õΩ', can.x-12, can.y+6);
                ctx.fillStyle = '#d1b45a';
            });

            // zombies (slow, relentless)
            ctx.fillStyle = '#6b4226';
            ctx.shadowColor = '#2f1f0f';
            zombies.forEach(z => {
                ctx.beginPath();
                ctx.arc(z.x, z.y, z.r, 0, 2*Math.PI);
                ctx.fill();
                ctx.fillStyle = '#431f0f';
                ctx.beginPath();
                ctx.arc(z.x-5, z.y-5, 5, 0, 2*Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(z.x+5, z.y-5, 5, 0, 2*Math.PI);
                ctx.fill();
                ctx.fillStyle = '#ad3a3a';
                ctx.beginPath();
                ctx.arc(z.x-2, z.y+3, 3, 0, 2*Math.PI);
                ctx.fill();
                ctx.fillStyle = '#6b4226';
            });

            // player (the lone survivor)
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#3b8f8f';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.r, 0, 2*Math.PI);
            ctx.fill();
            ctx.fillStyle = '#f4e8c1';
            ctx.font = '26px monospace';
            ctx.fillText('üßç', player.x-20, player.y+10);
            ctx.shadowBlur = 0;

            // carried fuel indicator (if >0)
            if (carriedFuel > 0) {
                ctx.fillStyle = '#ffe68f';
                ctx.font = 'bold 20px monospace';
                ctx.fillText(`+${carriedFuel}`, player.x-40, player.y-30);
            }

            // game over / win overlay
            if (!gameActive) {
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#0a0f0a';
                ctx.fillRect(0, 0, W, H);
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#ebcba0';
                ctx.font = 'bold 38px monospace';
                ctx.fillText(gameWin ? 'üèÅ ESCAPED' : 'üíÄ DIED', 220, 300);
            }
        }

        // main game loop
        function gameLoop() {
            if (gameActive && !gameWin && !gameOver) {
                // spawning
                spawnTimer++;
                if (spawnTimer >= SPAWN_DELAY) {
                    spawnZombie();
                    spawnTimer = 0;
                }

                movePlayer();
                handleItemCollection();
                depositFuelAtCar();
                moveZombies();
                handleZombieCollisions();

                // attack cooldown decrease
                if (globalAttackCooldown > 0) globalAttackCooldown--;

                updateUI();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ---------- INPUT (keyboard + mobile dpad) ----------
        function keyDownHandler(e) {
            const key = e.key;
            e.preventDefault(); // prevent scrolling
            if (!gameActive || gameWin || gameOver) return;
            switch(key) {
                case 'ArrowUp': moveUp = true; break;
                case 'ArrowDown': moveDown = true; break;
                case 'ArrowLeft': moveLeft = true; break;
                case 'ArrowRight': moveRight = true; break;
                case 'a': case 'A': attackZombies(); break;
            }
        }

        function keyUpHandler(e) {
            const key = e.key;
            switch(key) {
                case 'ArrowUp': moveUp = false; break;
                case 'ArrowDown': moveDown = false; break;
                case 'ArrowLeft': moveLeft = false; break;
                case 'ArrowRight': moveRight = false; break;
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.key.startsWith('Arrow') || e.key === 'a' || e.key === 'A') {
                e.preventDefault();
                keyDownHandler(e);
            }
        });
        window.addEventListener('keyup', keyUpHandler);

        // touch buttons
        document.getElementById('upBtn').addEventListener('touchstart', (e) => { e.preventDefault(); moveUp = true; });
        document.getElementById('upBtn').addEventListener('touchend', (e) => { e.preventDefault(); moveUp = false; });
        document.getElementById('downBtn').addEventListener('touchstart', (e) => { e.preventDefault(); moveDown = true; });
        document.getElementById('downBtn').addEventListener('touchend', (e) => { e.preventDefault(); moveDown = false; });
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft = true; });
        document.getElementById('leftBtn').addEventListener('touchend', (e) => { e.preventDefault(); moveLeft = false; });
        document.getElementById('rightBtn').addEventListener('touchstart', (e) => { e.preventDefault(); moveRight = true; });
        document.getElementById('rightBtn').addEventListener('touchend', (e) => { e.preventDefault(); moveRight = false; });

        // attack button
        document.getElementById('attackBtn').addEventListener('touchstart', (e) => { e.preventDefault(); attackZombies(); });
        // also for mouse (desktop)
        document.getElementById('attackBtn').addEventListener('mousedown', (e) => { e.preventDefault(); attackZombies(); });

        // reset button
        document.getElementById('resetBtn').addEventListener('click', (e) => {
            e.preventDefault();
            resetGame();
            // reset movement flags
            moveUp = false; moveDown = false; moveLeft = false; moveRight = false;
            carriedFuel = 0;
        });

        // prevent context menu on canvas
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // start game
        resetGame();
        gameLoop();
    })();
</script>
</body>
</html>
